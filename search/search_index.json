{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Modelling Materials with Density Functional Theory","text":""},{"location":"#introduction","title":"Introduction","text":"<p>This is the lab material for the Imperial College London, Department of Materials course \"MSE404: Modelling Materials with Density Functional Theory\".</p> <p>This course is intended to introduce students to the modelling of materials with density-functional theory (DFT). In the labs we will use the free, open-source DFT code Quantum Espresso, but while the format of the input files may change in other DFT codes, the general principles will be the same. The labs will also briefly introduce student to the use of the Linux OS and how it enables the effective use of computational resources, as well as showing students some simple scripting, analysis, and visualization tools.</p>"},{"location":"#structure-of-the-labs","title":"Structure of the Labs","text":"<p>The labs are organised as follows:</p> <ul> <li>Lab 1: Getting started in Linux</li> <li>Lab 2: Quantum Espresso Input and Output</li> <li>Lab 3: Converging your Calculations</li> <li>Lab 4: The Electronic Band Structure and Density of States</li> <li>Lab 5: Forces, Stresses and Structures</li> <li>Lab 6: Vibrational Frequencies and Normal Modes</li> <li>Lab 7: Finite Temperature Properties</li> <li>Lab 8: Spin Polarization and Magnetic Systems</li> <li>Lab 9: Optical Properties and Time-Dependent Density Functional Theory </li> </ul> <p>Additional Material:</p> <ul> <li>Calculating Useful Properties from Total   Energies</li> <li>Examining the Charge Density and Wavefunction</li> <li>The Hydrogen Atom and Electron Spin</li> <li>The Tetrahedron Method for Densities of States</li> <li>Optical Properties and Time-Dependent Density Functional Theory</li> </ul> <p>Extras:</p> <ul> <li>Setting up a virtual machine</li> <li>More Useful Linux Commands</li> <li>Plotting with Gnuplot</li> <li>Bash and Shell Scripting</li> <li>Running in Parallel</li> </ul>"},{"location":"#how-to-use-this-material","title":"How to Use this Material","text":"<p>The latest version of the course is available online at https://github.com/Chengcheng-Xiao/mse404. The text source files named <code>readme.md</code> in the various directories use markdown. You can download the whole repository and view them in a terminal, or read them at the Github site https://chengcheng-xiao.github.io/mse404/.</p> <p>Each lab is designed to be self-contained. The webpage will show the general direction and explain the concepts, while the input files and scripts are stored in directories located along side the <code>readme.md</code> file, labeled by their apparences in the text. </p> <p>There will be code blocks like the one below in the text <pre><code>echo \"Hello World\"\n</code></pre> which are meant to be run in the terminal. And you can click the   icon on the right to copy the code to your clipboard.</p> <p>There will also be inline annotations () like the one  below:</p> <pre><code>program hello\n    print *, \"Hello World\" !(1)\nend program hello\n</code></pre> <ol> <li>Print the string \"Hello World\" to the terminal.</li> </ol> <p>You can click on the annotation to see the explanation.</p> <p>There will also be admonitions like the one below:</p> <p>Coder's Tip [important]</p> <p>Don'f forget to add comments to your code to explain what you are doing!</p> Coder's Tip [side-note] <p>Don't forget to sleep and eat! (well, this is important too!)</p> <p>where important/optional information is given. Also, the Tasks will also be marked as admonitions like the one below:</p> <p>Taks 1 - Read me</p> <p>Read this <code>readme.md</code> file.</p>"},{"location":"#acknowledgements","title":"Acknowledgements","text":"<p>Webpage refreshed by Chengcheng Xiao, 2024.</p>"},{"location":"labs/extras/labs/high_symmetry_points/readme/","title":"Extra: High Symmetry Points","text":"<p>High symmetry points</p> <p>If you have a particular structure and you want to find out which are the important k-points, then this website is a useful tool.</p> <p>Finding appropriate high symmetry points and their labels for a band structure plot is beyond the scope of this course, but generally you need to find the Brillouin zone for the system you're interested in, along with the names of the high symmetry points, and how these should be represented in terms of your reciprocal lattice vectors.</p> <p>These can often be looked up in a table for a given structure, while keeping in mind that even for the same structure you may come across papers where some zone boundary high symmetry points will be labelled differently. You can access these tables online at e.g. the Library of Crystallographic Prototypes by typing the name of the mineral into the search box. This will give you the space group number, which you could then use with e.g. the Bilbao Crystallographic Server to find the reciprocal space coordinates of the high symmetry points and their labels. Another good reference is TU Graz which has nice interactive visualizations of the most common types along with their labels.</p> <p>For the diamond lattice example, we might do this as follows:</p> <ul> <li>The diamond lattice is FCC. We can find find the space group number from   http://aflow.org/CrystalDatabase/A_cF8_227_a.html and see that it is   number 227.</li> <li>We can enter this number at http://www.cryst.ehu.es/cryst/get_kvec.html   and find several high symmetry points. Often, you'll want to pick the same   path that was chosen in some previous work to ensure you can reproduce it   correctly. In   <code>02_C_diamond_nscf.in</code>   we have set up an input file for the path <code>\u0393-K-X-\u0393'-L-X-W-L</code> where <code>\u0393'</code>   indicates the gamma point in a different Brillouin zone. Note - these   labels don't exactly match points given in the table. Many points have   a number of equivalent positions on the Brillouin zone surface, and often   different conventions can be used for different materials with the same   structure.</li> </ul>"},{"location":"labs/extras/labs/hydrogen_atom/readme/","title":"Additional Material: The Hydrogen Atom and Electron Spin","text":"<p>As an example of a system where spin is important, let's look again at hydrogen. In the molecule we have two hydrogen atoms bonded together, and two electrons in total, and we can do this with a standard calculation.</p> <p>But if we instead want to find the energy of an isolated H atom accurately it's a little more tricky. A hydrogen atom has one electron, which means if we treat it with doubly-degenerate bands, we would have a single half occupied band. To calculate it like this we can treat it as a metal, and use some small smearing, so that we allow partial occupation of bands. This is equivalent to assuming that we have half an electron in each spin state. If we however restrict it to being in one spin state or another, we may find a slightly different energy (coming primarily from differences in how the DFT exchange term is calculated in each case, with the latter being more physical).</p> <p>The directory <code>01_H1_metal</code> has an input file for a single H atom using a small smearing, while the directory <code>01_H1_spin</code> has the same calculation, but with no smearing, and we have used the input variables <code>nspin</code> and <code>tot_magnetization</code> to enable a spin polarized calculation.</p> <ul> <li>Run the input files in these two folders.</li> <li>Compare the total energy obtained in each case. In which case is the   energy lower?</li> <li>Compare the energies of the lowest energy calculated bands.<ul> <li>Enabling smearing for the \"metal\" calculation will automatically add   extra bands, but only the lowest energy band will be occupied in this   calculation.</li> <li>In the spin polarized calculation if you check the output you will see   two sections for the band energies. One listing the energies of the   \"spin up\" bands, and the other listing \"spin down\" bands. Since we   have said we want 1 spin up electron in the calculation, the spin up   band will be occupied and should be lower in energy than the   unoccupied spin down band.</li> </ul> </li> <li>Slightly above the band energies in the output of the spin polarized   calculation, you'll see that quantum espresso also outputs the magnetic   moment associated with each atom in the system. And slightly below the final   total energy output, it will list the total magnetization of the system in   Bohr magnetons per cell. The  measured value for hydrogen is 1. How close   are you here?</li> </ul>"},{"location":"labs/extras/labs/tddft/readme/","title":"Additional Material: Optical Properties and Time-Dependent Density Functional Theory","text":"<p>Among the most useful class of properties to be able to predict for a molecule or crystal are its optical properties. These can be used to find the frequencies of optical radiation that will be absorbed or emitted, based on its electronic structure. This can be used to find, for example, what colour a dye molecule will have in a solvent.</p> <p>There are several ways these properties could be calculated starting from density functional theory. The method we'll look at in this lab is time-dependent density functional theory (TDDFT). A TDDFT code could be used to calculate the evolution of the electrons under the effect of the oscillating electric field associated with the presence of a photon. This would be a fairly intensive calculation, and would need to be repeated at many different energies to build up the full optical spectrum.</p> <p>The set of codes that comes with the quantum espresso package, turboTDDFT, actually use time-dependent density functional perturbation theory (TDDFPT) to calculate optical spectra of molecules. This calculates the response of the system to the oscillating electric field associated with an incoming photon using perturbation theory (polarizability), in a similar way to how DFPT finds the response of the system to perturbations of the atomic positions. It then uses this to find the susceptibility as a function of photon energy. The code also uses an approach known as the Liouville-Lanczos method which allows it to calculate the full optical spectrum for a wide energy range, at a very moderate cost.</p> <p>Typically if you want to understand what energy of photon will be absorbed, you might expect you would need to know the difference between the energy of the occupied and empty states: when a photon is absorbed it excites an electron from an occupied state to an empty state higher in energy by an amount equal to the photon energy. The turboTDDFT codes use a clever approach to avoid the need for including a large number of additional empty states in the calculation. This involves instead using the projection operator on to the occupied states. Details of this are given in a paper outlining the methods used in the turboTDDFT code. This is distributed with the quantum espresso package. You can find it on the mt-student server in <code>/opt/share/quantum-espresso/doc-6.3/turboTDDFT-CPC.pdf</code>. There are also slides on the quantum espresso website outlining the approach and making a comparison to the more basic TDDFT method at https://www.quantum-espresso.org/resources/tutorials/shanghai-2013/TDDFT_Talk_Gebauer.handouts.pdf</p> <p>Despite the various advantages offered by the approaches used in this code, this will still be the most intensive calculation you'll have done so far. However it is much faster than would be the case if we needed to manually look at many photon energies and including many empty states in our DFT calculation.</p> <p>You should also keep in mind that this approach is for fixed nuclear positions and does not include the effect of interatomic vibrations which may also couple to an incoming photon, either directly if the energy range is similar, or indirectly if, for example, a photon creates an excited electron and vibration simultaneously. Generally by looking in a particular energy range, the dominant effects will be from one mechanism or another. For example, the homo-lumo gap in methane is around 10 eV in LDA-DFT, while the highest energy atomic vibrations are around 0.4 eV. This means that if we're looking at the effect of photons in the 10-50 eV range (vacuum UV to extreme UV), the effect of the atomic vibrations will be minor. But we don't immediately have the spectrum across all energy ranges.</p> <p>As with some of the other more advanced calculations we looked at, we'll be doing this calculation in several stages:</p> <ol> <li>A self consistent calculation of the molecule is performed. We can do this    in the same way as previously. No special inputs are needed.</li> <li>We'll use the <code>turbo_lanczos.x</code> code which does the TDDFPT calculation    using the aforementioned Liouville-Lanczos method. This is the first, and    more computationally intensive step in calculating the polarizability. It    calculates the components of a tridiagonal matrix that will be used in a    subsequent code, for each optical polarization direction.</li> <li>We'll use the <code>turbo_spectrum.x</code> code to take the tridiagonal matrix    generated in the previous step, generate the polarizability and from it    find both the susceptibility tensor and the oscillator strength as a    function of photon energy.<ul> <li>The susceptibility tensor relates the electric field to the induced    electric polarization</li> <li>the oscillator strength gives the probability of absorption or emission    of photons.</li> </ul> </li> </ol>"},{"location":"labs/extras/labs/tddft/readme/#optical-spectrum-of-methane","title":"Optical Spectrum of Methane","text":"<p>The directory <code>CH4</code> contains a set of example inputs to perform this calculation for a methane molecule.</p> <ul> <li>Start by examining the <code>pw.x</code> input file   <code>01_CH4_scf.in</code>. You'll see that we have set this up as   usual. We have specified both the <code>prefix = CH4</code> and <code>outdir = './out'</code> as   this calculation generates many intermediate files, so it will be easier to   keep them all together. We have also set the positions such that the C atom   is at the centre of the cell. This will make some subsequent visualization a   little easier.</li> <li>Run <code>pw.x</code> with this input file and examine the output to ensure it worked   as expected.</li> <li>Next take a look at the <code>turbo_lanczos.x</code> input file   <code>02_CH4_tl.in</code>. This is fairly short. As usual, we have   accepted the default values for most of the input parameters. You can see   the full list of inputs in the <code>INPUT_LANCZOS.txt</code> file in the quantum   espresso documentation directory. We have specified two sections in the   input file:<ul> <li><code>LR_INPUT</code> where we set the <code>prefix</code> and <code>outdir</code> to match the scf   calculation, and</li> <li><code>LR_CONTROL</code> where we set<ul> <li><code>itermax = 400</code> which tells it how many elements of the Lanczos   chain to calculate (elements of the tridiagonal matrix). While in   principle more elements will give us a more accurate result, the   subsequent code can extrapolate these to a very high number. Usually   on the order of 500 to 1000 is sufficient to calculate explicitly,   though we'll look at how this converges later. It is connected to   how well the spectral features can be resolved in your calculation.</li> <li><code>ipol = 4</code> which tells it to calculate the response in all 3   directions: x, y and z.</li> </ul> </li> </ul> </li> <li>Run <code>turbo_lanczos.x</code> with this input file. It will likely take somewhere   around five minutes on the mt-student server. If you follow the output as it   is generated, you will see it calculating each of the 400 requested   iterations in turn for each of the three polarization directions.</li> <li>Finally take a look at the <code>turbo_spectrum.x</code> input file   <code>03_CH4_ts.in</code>. We need to set a few more things here.   As before, you can see a full description of all the input parameters that   can be used with this code in <code>INPUT_SPECTRUM.txt</code> in the quantum espresso   documentation directory. It has a single section: <code>LR_INPUT</code>. Again we set   the prefix and outdir to match the previous calculations. Then we have:<ul> <li><code>itermax0</code> which needs to match the number of iterations calculated   explicitly by <code>turbo_lanczos.x</code>.</li> <li><code>itermax</code> which says how many iterations in total to calculate. Those   not explicitly calculated are generated using an extrapolation scheme.</li> <li><code>extrapolation</code> sets the approach used in the extrapolation.</li> <li><code>espil</code> sets a broadening to use (in Ry). Very small wiggles will appear   in the output spectrum if this is too small, and if it is too large it   may obscure important features.</li> <li><code>units</code> sets the output units. We use <code>1</code> here we means the output   energies are in eV (rather than Ry by default).</li> <li><code>start</code>, <code>end</code> and <code>increment</code> specify the range of energies to output   and the spacing between them (in the units specified by the <code>units</code>   input).</li> <li><code>ipol</code> specifies the polarization direction. We set this to <code>4</code> again   for all three cartesian directions.</li> </ul> </li> <li>Run <code>turbo_spectrum.x</code> with this input file. This is quite a quick   calculation, and should finish in 10 to 20 seconds. The output file mainly   contains the stages of the calculation.</li> <li>The main output is instead in the file <code>CH4.plot_chi.dat</code> which will be   generated. This lists each energy value and its corresponding susceptibility   tensor and oscillator strength.</li> </ul> <p>Take a look at the file <code>CH4.plot_chi.dat</code> now. You'll see the file is not really amenable for plotting.</p> <ul> <li>First we can extract the oscillator strength with the following awk command:</li> </ul> <p><pre><code>awk '/S\\(E\\)=/{print $2, $3}' CH4.plot_chi.dat &gt; ostrength.dat\n</code></pre> This will print the second and third character on every line containing the text <code>S(E)=</code> (we need to use a <code>\\</code> to escape the parentheses). This extracts the oscillator strength as a function of energy (in eV since we set <code>units = 1</code> in the <code>turbo_spectrum.x</code> input file).</p> <ul> <li>Plot the file containing the oscillator strength as a function of energy in   gnuplot so you can see where the peaks in absorption are.</li> </ul> <p>It's also interesting to look at the susceptibility. As the system is isotropic, the polarizability, and hence susceptibility in each of the three Cartesian directions is the same. This means looking at the <code>_11</code> component alone is sufficient. This is a complex number, and we should look at both the real and imaginary parts.</p> <ul> <li>Parse the energy, the real and the imaginary part of the susceptibility   (from the 11 component of chi in the <code>plot_chi.dat</code> file) and plot both the   real and imaginary parts together in gnuplot.<ul> <li>If you parse this to a file with three columns: x, y1, y2, you can plot   them together in gnuplot as   <code>plot \"file\" with lines, \"file\" using 1:3 with lines</code>.</li> <li>You can plot several plots together by separating them with commas, and   you can use the keyword <code>using</code> to specify the columns to plot (it is   <code>1:2</code> by default).</li> </ul> </li> </ul>"},{"location":"labs/extras/labs/tddft/readme/#charge-density-response","title":"Charge Density Response","text":"<p>It can also be interesting to examine how the charge density actually varies in response to a photon at a given energy (and hence frequency) and polarization. In particular it's useful to look at the response to photons at the energy where the highest peak in the oscillator strength is.</p> <p>This can be done using an additional flag and input section in a <code>turbo_lanczos.x</code> calculation, following a previous <code>turbo_lanczos.x</code> calculation for all polarization directions.</p> <p>Take a look at the input file <code>04_CH4_tl.in</code>. In this file we have set the <code>LR_CONTROL</code> section inputs:</p> <ul> <li><code>itermax = 400</code> which matches what we had previously.</li> <li><code>charge_response = 1</code> which turns on the calculation of the charge response.</li> <li><code>ipol = 1</code> which set the polarization of the calculated charge response to   be along the x-direction.</li> </ul> <p>Then we have added an addition section <code>LR_POST</code>, which is needed whenever <code>charge_response</code> is set to 1. Here we have set the following:</p> <ul> <li><code>omeg = 1.08</code> which set's the energy of the photon for which we want to   calculate the response. This is in Ry, and corresponds to 14.7 eV which is   roughly where the peak of the oscillator strength is for this level of   (under)convergence.</li> <li><code>epsil = 0.02</code> this is an energy broadening to use when calculating the   response (in Ry).</li> <li><code>w_T_npol = 3</code> which says that we calculated the response to all three   polarization directions in our previous calculation.</li> <li><code>plot_type = 3</code> which selects the output file to be in the gaussian cube   format. This can be opened with xcrysden.<ul> <li>Note: it seems there may a bug with this output for the version compiled   on the mt-student server such that for particular choices of energy   cut-off, box-size and output format, the output file is cut off before   the end and can't be plot. For the values chosen here, it should work   hopefully work correctly.</li> </ul> </li> </ul> <p>Run <code>turbo_lanczos.x</code> with this input file. It'll take a couple of minutes to finish. Once completed you'll see either a pair of files named <code>CH4-absorbtive-pol1.cube</code> and <code>CH4-dispersive-pol1.cube</code> have been created, or a single file named <code>CH4-summed-rho-pol1.cube</code>. The former are generated where the code determines the energy <code>omeg</code> (including the broadening <code>epsil</code>) you are calculating at corresponds to a resonance where there is a peak in the spectrum, and the latter is output otherwise. In our case we should be within the broadening of a resonance peak and so two files should be output.</p> <p>Open <code>xcrysden</code>, which we used to look at crystal and molecular structures in the extra section at the end of lab 2, (don't forget to load the module). Use this to open one of the generated files by navigating through File -&gt; Open Structure -&gt; Gaussian98 Cube File, and selecting the file. You can look at the regions where the charge density is increased and decreased in response to the oscillating electric field of the photon by going to Tools -&gt; Data Grid, click OK. Then select an appropriate Isovalue in the menu that appears, tick the <code>Render +/- isovalue</code> box, and click <code>Submit</code>. To find a good isovalue you can repeat this process with different values within the listed maximum and minimum on the grid till you see something interesting; the menu will stay visible after you click submit.</p>"},{"location":"labs/extras/labs/tddft/readme/#convergence","title":"Convergence","text":"<p>The calculated spectrum is quite sensitive to both the box size, the plane-wave energy cut off, and the number of elements of the Lanczos chain explicitly calculated, as set by the <code>itermax</code> variable in the <code>turbo_lanczos.x</code> input file. (And subsequently used as <code>itermax0</code> in the <code>turbo_spectrum.x</code> input file). These are all somewhat somewhat underconverged in the input file given to you earlier so that the calculation would complete in a reasonable time. And are somewhat connected to each other: e.g. the spectrum may be converged at a higher value of <code>itermax</code> for a higher value of <code>ecutwfc</code> so that testing convergence can be time consuming.</p> <p>Underconverging your spectra can lead to the appearance of spurious peaks and shoulders and to changes in the locations of different peaks. So you will always need to explicitly check the convergence of your spectra with respect to these parameters.</p> <p>As it would take quite a few heavy calculations to for you to test this, the oscillator strengths for methane for various box sizes, energy cut-offs and values of <code>itermax</code> have been pre-calculated in the <code>CH4_convergence</code> directory. For the various files here, in the filename the box dimension in Angstrom is indicated by the number following <code>A</code>, the plane-wave energy cut-off in Ry is indicated by the number following <code>e</code>, and the value of itermax is indicated by the number following <code>i</code>. Try plotting and comparing combinations of these in gnuplot to see how the spectrum changes as these parameters are changed.</p> <p>Note: if you are testing the convergence with respect to <code>itermax</code>, you can generate output from <code>turbo_spectrum.x</code> where <code>itermax0</code> is any value up to the value chosen for <code>itermax</code> in the <code>turbo_lanczos.x</code> calculation. So for example, if you have calculated a spectrum with <code>itermax = 500</code> in <code>turbo_lanczos.x</code>, you can quickly generate output for say 400 by setting <code>itermax0 = 400</code> in <code>turbo_spectrum.x</code>, rather than doing a full recalculation with a lower value of <code>itermax</code> in <code>turbo_lanczos.x</code> which would be far more time consuming.</p>"},{"location":"labs/extras/labs/tddft/readme/#summary","title":"Summary","text":"<p>In this lab you have seen how to use the turboTDDFT codes for performing and analysing TDDFT from the quantum espresso package to</p> <ul> <li>calculate the optical spectrum of a molecule by<ul> <li>Performing a self-consistent DFT calculation with <code>pw.x</code>.</li> <li>using the <code>turbo_lanczos.x</code> code to perform a TDDFPT calculation as   the first step in calculating the polarizability.</li> <li>using the <code>turbo_spectrum.x</code> code to generate the polarizability and   find both the susceptibility tensor and oscillator strength as a   function of photon energy.</li> </ul> </li> <li>You have also used <code>turbo_spectrum.x</code> to calculate the charge density   response of a molecule and visualised it with <code>xcrysden</code>.</li> </ul>"},{"location":"labs/extras/labs/tddft/readme/#extra-li2","title":"Extra - Li2","text":"<p>If you want to practice this type of calculation a bit more, the directory <code>Li2</code> contains a pseudopotential for lithium. You can use this to do the following set of calculations:</p> <ul> <li>Find the optimal bond length for an Li2 molecule by relaxing the atomic   positions as shown in previous labs.</li> <li>Calculate the oscillator strength as a function of energy.</li> <li>You will likely need to play around with the values of the energy range to   use in the <code>turbo_spectrum.x</code> calculation to find the best values to   show the main peaks.</li> </ul>"},{"location":"labs/extras/labs/tetrahedron_method/readme/","title":"Additional Material: The Tetrahedron Method for Densities of States","text":"<p>You saw in lab 4 how to calculate densities of states using broadening, in this section we look at how to use the tetrahedron method.</p>"},{"location":"labs/extras/labs/tetrahedron_method/readme/#density-of-states-using-the-tetrahedron-method","title":"Density of states using the tetrahedron method","text":"<p>To use the tetrahedron method this within quantum espresso, you must use the tetrahedron occupation scheme for the DFT calculation, and then don't set any <code>degauss</code> value in the <code>dos.x</code> input file. This is outlined in the <code>INPUT_DOS.txt</code> help file.</p> <p>An example where we have modified the diamond input files from lab 4 to calculate the density of states using tetrahedron integration is given in the <code>01_diamond_tet</code> directory. </p> <p>If you run the same three steps for calculating densities of states using broadening again here, you'll once again produce a <code>pwscf.dos</code> file. If you  check the output file from the <code>dos.x</code> calculation you'll also see the note <code>Tetrahedra used</code>, whereas the previous output notes details of the broadening.</p> <p>Additionally if you look at the header of the <code>pwscf.dos</code> file you'll see a different value for the Fermi energy than we obtained in the previous calculation. This would mainly come from a small underestimation that happens in the tetrahedron method. You can also see this in the integrated DOS in comparison to the broadening case. For this reason a separate calculation of the Fermi energy may often be useful. Note, you'll get more well defined features and a smoother curve systematically as you increase the k-point sampling density. The calculation will take a lot longer; if you use e.g. a 60x60x60 grid in the nscf calculation it takes about 15 mins run in serial, and the DOS calculation takes about 20 minutes, though this may be worth it if producing an image for a paper or report. We've tried to keep run time for example calculations provided down to a couple of minutes or less.</p>"},{"location":"labs/extras/labs/tetrahedron_method/readme/#task","title":"Task","text":"<ul> <li>Plot the density of states and compare it that obtained using Gaussian   broadening in lab 4.</li> </ul>"},{"location":"labs/extras/labs/using_total_energies/readme/","title":"Additional Material: Calculating Useful Properties from Total Energies","text":"<p>Once you can calculate a converged total energy for a given structure, you already know enough to calculate many useful materials properties.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#what-can-we-do-with-total-energies","title":"What can we do with total energies?","text":"<p>The DFT total energy on its own is not a very useful number, but changes and differences in the total energy with respect to some input parameter can be used to calculate many materials properties.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#predicting-volume","title":"Predicting volume","text":"<p>If we calculate the total energy of say diamond as a function of volume, the volume at which the total energy is minimized will be the theoretically predicted volume.</p> <p>Let's do this in the directory <code>01_diamond_volume</code>. We could set up a series of calculations manually, where we generate a set of input files each with a slightly different value of the input lattice length. Then we would run each of these calculations, and finally gather the total energy vs cell volume in a data file. Or, we could write a script that would do all this for us.</p> <p>We already have a template file set up as <code>C_diamond_base.in</code>. Take a look at this now. It's set up such that the value of the <code>A</code> variable will be replaced in the automatically generated input files. Note, we're using a fairly high energy cut-off here also. In principle once the calculation is set up, we will need to explicitly test the convergence of the predicted volume versus energy cut-off.</p> <p>The script will need to be slightly more complex than previously, as we'd managed to get by with just producing integer values in our scripts previously. Now we'll need to produce floating point values for <code>A</code> to get the resolution we would like. To do this, we can use the <code>bc</code> command to perform the calculation of the lattice length for a given input file.</p> <p>Also Quantum Espresso outputs the unit cell volume (in Bohr cubed) so we can read this rather than calculating it ourselves.</p> <p>This gives us the following script:</p> <pre><code>#!/bin/bash\n\ntemplate=\"C_diamond_base.in\"\nrepstr=\"xxxx\"\n\n# The \"for\" construction we've used previously only handles integers.\n# So we set an initial value for A and its delta value as variables.\na1=3.40\nda=0.02\n\nfor i in {00..10..1}\ndo\n  inp=\"C_diamond_${i}.in\"\n  # bc is a calculator that can calculate expressions in the shell. We\n  # pass it our calculation with echo and save the result as a variable.\n  a=$(echo \"$a1 + $i * $da\" | bc)\n  sed \"s/$repstr/$a/\" $template &gt; $inp\n  pw.x &lt; $inp &amp;&gt; ${inp%.*}.out\ndone\n\nawk '/unit-cell volume/{vol=$4}\n     /^!.*total/{print vol, $5}' *out &gt; etot_v_vol.dat\n</code></pre> <p>Save this script in the calculation directory and use it to obtain a file with the total energy versus volume of carbon diamond.</p> <p>Let's generate a plot of this with <code>gnuplot</code> and make sure it looks sensible. A simple <code>gnuplot</code> script <code>etot_v_vol.gpl</code> is already in the calculation directory. The contents are as follows:</p> <p><pre><code>set title \"Carbon Diamond, ecutwfc=60 Ry\"\nset xlabel \"Unit Cell Volume (Bohr^3)\"\nset ylabel \"Total Energy (Ry)\"\nset term pngcairo\nset output \"etot_v_vol.png\"\nplot \"etot_v_vol.dat\"\n</code></pre> This sets a title and axes labels, sets the output type to png, and sets and output filename, then plots the data as we've seen before. All these commands could be entered directly in gnuplot, but it can be easier to save them as a script if you want to come back in the future and make minor modifications. If your run this script with <code>gnuplot etot_v_vol.gpl</code> you'll see a png file of the plot has been produced in the directory. You can quickly view this with <code>display etot_v_vol.png</code>.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#task","title":"Task","text":"<ul> <li>What is the calculated volume with the lowest total energy?</li> <li>What lattice length does this correspond to?</li> <li>Modify the script to calculate 21 points from A=3.40 to A=3.60 inclusive.</li> <li>Repeat this last calculation for energy cut-offs of 40 Ry and 80 Ry. Note,   you should set a different filename for the data file each time or rename   the previous data file before running this so you can compare them all   directly..</li> <li>Plot all the data for all three energy cut-offs together in gnuplot. Note   you can plot several data files in gnuplot by separating them with a comma -   e.g. <code>plot \"data1.dat\", \"data2.dat\"</code>. Save the output as a png file.</li> </ul>"},{"location":"labs/extras/labs/using_total_energies/readme/#bulk-modulus-of-diamond","title":"Bulk Modulus of diamond","text":"<p>You may have realised that we could use the results of our previous calculations to predict the bulk modulus of diamond. The bulk modulus is proportional to the second derivative of the energy with respect to volume at the equilibrium volume. Say we approximate our crystal as a harmonic solid, then we could fit a harmonic expression to it to obtain a value for the bulk modulus, K in <code>gnuplot</code>. We can do that, and plot the fit together with our data with the following <code>gnuplot</code> script.:</p> <pre><code># Define a function for a simple harmonic equation of state\nE(x) = E0 + K*(x - V0)**2/(2*V0)\n# It's better to give initial guesses for a good fit. You can make a good\n# guess at E0 and V0 from the data plot you generated earlier.\nE0=-22.782\nV0=74\n\n# The actual fit command. The parameters and errors will be output to your\n# terminal and to the file 'fit.log'.\nfit E(x) \"etot_v_vol.dat\" via E0, V0, K\n\n# Let's also produce a plot of the fit along with our data. We can use the\n# same settings as before.\nset title \"Carbon Diamond, ecutwfc=60 Ry\"\nset xlabel \"Unit Cell Volume (Bohr^3)\"\nset ylabel \"Total Energy (Ry)\"\nset term pngcairo\nset output \"etot_v_vol_fit.png\"\n\n# The fit parameters are set a their optimized values at the end of the fit\n# command above, so we can simply plot E(x).\nplot \"etot_v_vol.dat\", E(x)\n</code></pre> <p>Looking at the fit parameters, we can see that we obtain a value for K and the equilibrium volume V0 directly. The value of V0 will be in whatever units were used for input volumes, so Bohr^3 in our case. The value of K will be in units of Energy/Volume. If we want to compare to the experimental value we'll need to convert to a more standard unit. 1 Ry is 2.179872325E-18 J, and 1 Bohr^3 is (5.2917721067E-11)^3 m^3. If you don't want to be copy and pasting numbers to a spreadsheet or similar, another useful way to do calculations in the terminal is using python. Type <code>python</code> to start an interactive session. Type whatever expressions you want, and type <code>ctrl+d</code> or <code>quit()</code> to exit python once you're done.</p> <pre><code>python\n&gt;&gt;&gt; K * 2.179872325E-18 / (5.2917721067E-11)**3 # Enter your K value here.\n&gt;&gt;&gt; _ * 1e-9 # Convert the last result ('_') to GPa\n</code></pre> <p>The usual measured value for the bulk modulus of diamond is around 540 GPa. How close to this are we?</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#task_1","title":"Task","text":"<ul> <li>Convert the fit error to GPa also so we have an estimate of our accuracy.</li> <li>Repeat the above fit for the data produced with different energy cut-off   earlier. How do the values and errors compare?</li> <li>A more advanced expression for the equation of state in a solid is the   Birch Murnaghan Equation of   State.   See if you can fit this expression to your data. The E(V) expression could   be written in gnuplot as   <pre><code>  E(x) = E0 + 9.0/16.0*V0*K*( Kp*((V0/x)**(2.0/3.0) - 1)**3 + ((V0/x)**(2.0/3.0) - 1)**2 * (6.0 - 4.0*(V0/x)**(2.0/3.0)))\n</code></pre><ul> <li>Note the expression also depends on the parameter Kp so you'll need   to add this to the list of fit parameters in the gnuplot <code>fit</code> command.</li> <li>How does the error in the fit value of <code>K</code> change with this new fit?</li> <li>Generate a plot showing both fits for your most well converged set of   data along with the data points.</li> </ul> </li> </ul>"},{"location":"labs/extras/labs/using_total_energies/readme/#h2-bond-length","title":"H2 Bond Length","text":"<p>For simple molecules we can calculate the total energy versus bond length in the same way. This calculation is set up in the directory <code>02_H2_bond</code>. Again, we're going to use a short script to modify a single value in a template input file and run a series of calculations. Take a look at the template input file first. We're not using any new inputs here. We've placed one atom at the origin, and the second will be moved along the x-axis.</p> <p>We'll make a few modifications to the script this time though so that we parse the data from the output files as they are generated and use the bond-length value from the script. Save the following to a script in the calculation directory:</p> <pre><code>#!/bin/bash\n\ntemplate=\"H2_base.in\"\nrepstr=\"xxxx\"\n\n# Again we set an initial value for the x-coordinate of on H-atom and a delta\n# value as variables.\nhx1=0.700\ndhx=0.005\n\n# Empty the file, since we'll be appending to it in the calculation loop.\n&gt; etot_v_bl.dat\n\nfor i in {00..40..1}\ndo\n  inp=\"H2_${i}.in\"\n  # We save the output filename to a variable also.\n  out=\"${inp%.*}.out\"\n\n  # Again we use bc to get the atomic position for each input.\n  hx=$(echo \"$hx1 + $i * $dhx\" | bc)\n  sed \"s/$repstr/$hx/\" $template &gt; $inp\n  pw.x &lt; $inp &amp;&gt; $out\n\n  # awk is inside the loop this time, and we are appending to the data file\n  # after each calculation completes.\n  awk -v bl=$hx '/^!.*total/{print bl, $5}' $out &gt;&gt; etot_v_bl.dat\ndone\n</code></pre> <p>Take a look at the data file. What bond length minimizes the energy?</p> <p>Plot this data in <code>gnuplot</code>. You may want to copy and modify the script we used earlier for diamond.</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#h2-vibration-frequency","title":"H2 Vibration Frequency","text":"<p>As you may have realised, we can use what we already calculated here to find the H2 vibration frequency. If we assume the variation in energy with bond length is approximately quadratic (how good an assumption do you think this is?) we can fit a function to the data in <code>gnuplot</code> and find the vibrational frequency.</p> <p>We can modify the gnuplot script we used earlier to fit and plot this function with our data as follows:</p> <pre><code>E(x) = E0 + k*(x-x0)**2\nfit E(x) \"etot_v_bl.dat\" via E0, x0, k\n\nset title \"Hydrogen Molecule\"\nset xlabel \"Bond Length (Angstrom)\"\nset ylabel \"Total Energy (Ry)\"\nset term pngcairo\nset output \"etot_v_bl_fit.png\"\n\nplot \"etot_v_bl.dat\", E(x)\n</code></pre> <p>Use this script to make a png plot and inspect it. How good a fit do you think we have?</p>"},{"location":"labs/extras/labs/using_total_energies/readme/#task_2","title":"Task","text":"<ul> <li>Modify the calculation script to calculate 40 values over a range of   0.1 Angstrom near the minimum. Also repeat the fit.<ul> <li>How does the fit compare to the previous one?</li> </ul> </li> <li>The fit has produced a value for an effective spring-constant k for the   H2 vibration. k is in units of Rydberg per Angstrom^2. Find the frequency   of vibration of the molecule in THz. Note, since we calculated k by fixing   one atom and moving the other, you will need to use the reduced mass of   the pair of atoms.<ul> <li>What would the frequency be for a molecule made of two deuterium atoms?</li> </ul> </li> </ul>"},{"location":"labs/extras/labs/visualising_output/readme/","title":"Additional Material: Examining the Charge Density and Wavefunction","text":"<p>In this lab we'll look at various ways of visualizing the output from your DFT calculations. To do this we'll be using several additional codes from the Quantum Espresso package.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#the-charge-density","title":"The Charge Density","text":"<p>To start with we'll try to visualise the charge density we have calculated for a methane molecule. Take a look at the directory <code>01_chargedensity/01_methane</code>. This is contains an input file for methane exactly as we've seen before. Note, we've set <code>disk_io = 'low'</code> which is the default value for an scf calculation (i.e. we could have omitted this and get the same output), as we want to keep the charge density file for analysis.</p> <ul> <li>Run <code>pw.x</code> with this input file now, and check the output to make sure it   all worked as expected. You should have both a <code>pwscf.save</code> directory   containing the charge density file and other output, and a <code>pwscf.wfc</code>   wavefunction file.</li> </ul> <p>Now we want to post-process this output into something we can visualise more easily. To do that we'll be using the <code>pp.x</code> code from the Quantum Espresso suite. This code can read the output files produced by <code>pw.x</code>, extract whatever quantity you're interested in and generate output compatible with various visualisation programs. There is a help file similar to the <code>pw.x</code> available in the Quantum Espresso documentation folder called <code>INPUT_PP.txt</code>.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#3d-visualization-with-xcrysden","title":"3D visualization with XCrySDen","text":"<p>There is a <code>pp.x</code> input file for methane called <code>CH4_pp.in</code>, that contains the following:</p> <pre><code> &amp;INPUTPP\n    filplot = 'methane_charge'\n    plot_num = 0\n /\n\n &amp;PLOT\n    filepp(1) = 'methane_charge'\n    iflag = 3\n    output_format = 5\n    fileout = 'CH4.rho.xsf'\n /\n</code></pre> <p>As you can see, the file format is quite similar to that used by <code>pw.x</code>. It contains two sections:</p> <ul> <li><code>INPUTPP</code> which has inputs controlling what data will be extracted from the   <code>pw.x</code> output.<ul> <li>If we had chosen non-default directories and names for the output files,   we would need to se them here.</li> <li><code>filplot</code> specifies a filename that will be used to save the extracted   data.</li> <li><code>plot_num</code> takes an integer option that specifies what quantity will be   extracted. 0 gives us the electronic density. There are many options   here, such as potentials and local density of states. See the help   file <code>INPUT_PP.txt</code> for details, including info on additional variables   that apply depending on this option.</li> </ul> </li> <li><code>PLOT</code> has inputs controlling how the extracted data will be output for    visualisation.</li> <li><code>filepp(1)</code> gives the name of the first file to read (it's possible to      read several files and combine them in various ways, such as to      generate charge density difference plots).</li> <li><code>iflag</code> gives the dimensionality of the output. We choose 3 here for a      3D plot.</li> <li><code>output_format</code> gives the type of format you want to have output, usually      this is determined by what application you'll be using to visualise the      data. It should also be compatible with the value of <code>iflag</code>. We've      selected 5 which will give us output compatible with <code>xcrysden</code>.</li> <li><code>fileout</code> specifies the name of the plot file. <code>xsf</code> is a default      <code>xcrysden</code> extension.</li> </ul> <p>We can run <code>pp.x</code> in the same way as <code>pw.x</code>:</p> <pre><code>pp.x &lt; CH4_pp.in &amp;&gt; CH4_pp.out\n</code></pre> <p>You'll see both a <code>methane_charge</code> and a <code>CH4.rho.xsf</code> file have been generated in the calculation directory. The charge file is in a binary format so we can't tell much about it. The <code>.xsf</code> file is in a text format so we can examine it (and modify it if we want) in a text editor. Take a look and you'll see the file simply defines the crystal lattice and basis, then has a section with the datagrid as a mesh of points.</p> <p>Launch <code>xcrysden</code> (recall you'll need to load the xcrysden module first with <code>module load xcrysden</code>), and load the file <code>CH4.rho.xsf</code>. You'll see a big cube, which has the carbon at each corner and whichever bound hydrogen falls within the cube nearby. This isn't ideal, but let's carry on for the moment. There's no sign of the charge density yet. To enable this, go to \"Tools\" -&gt; \"Data Grid\". You can click \"OK\" on the menu that appears, and then you'll see a menu that controls the data grid plot appearance. Try entering say \"0.1\" for the \"Isovalue\" and click \"Submit\". If you zoom into a carbon you'll see the cloud of charge around it. Unfortunately, since we have the carbon at the origin, this plot is a little hard to see.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#task","title":"Task","text":"<ul> <li>In a new directory <code>01_methane_shift</code>, shift the molecule such that the carbon atom is at the centre of the box in the <code>pw.x</code> input file.</li> <li>Run the <code>pw.x</code> and <code>pp.x</code> calculations as before.</li> <li>Visualise the output in <code>xcrysden</code>.<ul> <li>Disable the display of the crystal cell.</li> <li>Plot the data grid at an Isovalue of 0.27. You should also enable transparency, and increase the degree of the tricubic cpline to 2 or 3.</li> <li>Under \"Modify\" reduce the Ball Factor to reduce their size.</li> </ul> </li> <li>When you're happy with how it looks, save an image by first checking the   \"File\" -&gt; \"Print Setup\" menu. It's usually worth enabling anti-aliasing   here. Then go to \"File\" -&gt; \"Print\" and save the output as a png image.</li> <li>Why is there no density around the carbon atom?</li> </ul>"},{"location":"labs/extras/labs/visualising_output/readme/#2d-visualization-with-gnuplot","title":"2D visualization with GnuPlot","text":"<p>The other way to look at this would be as a 2D contour plot, or heat map. We can get 2D output suitable for gnuplot by setting the input for <code>pp.x</code> as in <code>CH4_pp_gp.in</code>: <pre><code> &amp;INPUTPP\n /\n\n &amp;PLOT\n    filepp(1) = 'methane_charge'\n    iflag = 2\n    output_format = 7\n    fileout = 'CH4.rho.gpl'\n    e1(1) = 0.4, e1(2) = 0.0, e1(3) = 0.0\n    e2(1) = 0.0, e2(2) = 0.0, e2(3) = 0.4\n    x0(1) = -0.2, x0(2) = 0.0, x0(3) = -0.2\n    nx = 100, ny = 100\n /\n</code></pre> This input file looks a little more involved than previously.</p> <ul> <li>We've left the <code>INPUTPP</code> section blank as we can simply re-use the   <code>methane_charge</code> file we created when we were generating output for   xcrysden earlier.</li> <li>We've updated <code>iflag</code> and <code>output_format</code> to select 2D output and gnuplot   format, and changed the output filename so we'll be able to understand what   this file was for in future.</li> <li>Now since we've selected 2D output, this means we need to define some   region to plot.<ul> <li>The <code>e1</code> and <code>e2</code> variables are vectors defining a plane   in units of the lattice constant.</li> <li><code>x0</code> defines the origin of the plane, again in units of the lattice   constant,</li> <li><code>nx</code> and <code>ny</code> are how many points to output in the grid.</li> <li>We've selected an xz plane which contains the carbon and two hydrogens.   Note, we've shifted the origin slightly so that the carbon will be in   the centre of the output. You'd need to adjust this to work for the   shifted structure in the task above.</li> </ul> </li> </ul> <p>Now when we run this with <code>pp.x</code> we (hopefully) get our <code>CH4.rho.gpl</code> data file as requested. You can take a look at this file, and you'll see it's a text list of numbers with <code>x, y, f(x, y)</code>. So you could use this in any plotting program or some other software or code for analysis easily.</p> <p>To plot in gnuplot you can set labels and do a heatmap style plot with the following gnuplot commands:</p> <pre><code>set title \"CH4 Charge Density in y=0 plane\"\nset xlabel \"x Position (Bohr)\"\nset ylabel \"z Position (Bohr)\"\nset cblabel \"Charge Density\"\nplot \"CH4.rho.gpl\" with image\n</code></pre> <p>Note, the x and y coordinates are output in Bohr atomic units as we've set in the plot here.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#visualizing-the-wavefunction","title":"Visualizing the Wavefunction","text":"<p>We can also try to visualise the wavefunction we have calculated for a methane molecule. Take a look at the directory <code>02_wavefunction/01_methane</code>. This is contains an input file for methane exactly as we've seen before. Note, we've set <code>disk_io = 'low'</code> which is the default value for scf calculations (i.e. we could have omitted this and get the same output), as we want to keep the wavefunction output file for analysis.</p> <ul> <li>Run <code>pw.x</code> with this input file now, and check the output to make sure it   all worked as expected. You should have both a <code>pwscf.save</code> directory   containing the charge density file and other output, and a <code>pwscf.wfc</code>   wavefunction file.</li> </ul> <p>Now we want to post-process this output into something we can visualise more easily. To do that we'll be using the <code>pp.x</code> code from the Quantum Espresso suite. This code can read the output files produced by <code>pw.x</code>, extract whatever quantity you're interested in and generate output compatible with various visualisation programs. There is a help file similar to the <code>pw.x</code> available in the Quantum Espresso documentation folder called <code>INPUT_PP.txt</code>.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#3d-visualization-with-xcrysden_1","title":"3D visualization with XCrySDen","text":"<p>There is a <code>pp.x</code> input file for methane called <code>CH4_pp.in</code>, that contains the following:</p> <pre><code> &amp;INPUTPP\n    filplot = 'CH4_wfn'\n    plot_num = 7\n    kpoint(1) = 1\n    kband(1) = 1\n    kband(4) = 4\n /\n\n &amp;PLOT\n    iflag = 3\n    output_format = 5\n    fileout = '.xsf'\n /\n</code></pre> <p>As you can see, the file format is quite similar to that used by <code>pw.x</code>. It contains two sections:</p> <ul> <li><code>INPUTPP</code> has inputs controlling what data will be extracted from the   <code>pw.x</code> output.<ul> <li>If we had chosen non-default directories and names for the output files,   we would need to set them here.</li> <li><code>filplot</code> as before specifies a filename that will be used to save the   extracted data.</li> <li><code>plot_num</code> takes an integer option that specifies what quantity will be   extracted. 7 gives us the wavefunction. There are many options here,   such as potentials and local density of states. See the help file   <code>INPUT_PP.txt</code> for details, including info on additional variables that   apply depending on this option.</li> </ul> </li> <li><code>kpoint(1)</code> is used to set the k-point index of the wavefunction we want      to output. There is only the gamma point in our calculation, so we can      set this to 1. For periodic materials where we have a grid of k-points we      could also specify <code>kpoint(2)</code> and generate output for a range of      k-points.</li> <li><code>kband(1)</code> and <code>kband(2)</code> are the lower and upper limits of the bands      that we want to output the wavefunction for.</li> <li><code>PLOT</code> has inputs controlling how the extracted data will be output for   visualisation.</li> <li><code>iflag</code> gives the dimensionality of the output. We choose 3 here for a 3D      plot.</li> <li><code>output_format</code> gives the type of format you want to have output, usually      this is determined by what application you'll be using to visualise the      data. It should also be compatible with the value of <code>iflag</code>. We've      selected 5 which will give us output compatible with <code>xcrysden</code>.</li> <li><code>fileout</code> usually specifies the name of the plot file, however for      wavefunction output where several files are generated, the text in      <code>fileout</code> is appended to the name of each file. <code>xsf</code> is a default      <code>xcrysden</code> extension, so we can add this here.</li> </ul> <p>We can run <code>pp.x</code> in the same way as <code>pw.x</code>:</p> <pre><code>pp.x &lt; CH4_pp.in &amp;&gt; CH4_pp.out\n</code></pre> <p>You'll see many files have been generated beginning with <code>CH4_wfn</code> followed by a k-point and band index. Each has a corresponding <code>.xsf</code> file. The <code>.xsf</code> files which we'll be using for visualization are in a text format so we can examine them (and modify them if we want) in a text editor. Take a look and you'll see the files simply defines the crystal lattice and basis, then have a section with the datagrid as a mesh of points.</p> <p>Launch <code>xcrysden</code> (recall you'll need to load the xcrysden module first with <code>module load xcrysden</code>), and load the file <code>CH4_wfn_K001_B001.xsf</code>. You'll see a big cube, which has the carbon at each corner and whichever bound hydrogen falls within the cube nearby. This isn't ideal, but let's carry on for the moment. There's no sign of a wavefunction yet. To enable this, go to \"Tools\" -&gt; \"Data Grid\". (Make sure you're x2go window and your xcrysdent window are big enough to see this). You can click \"OK\" on the menu that appears, and then you'll see a menu that controls the data grid plot appearance. Try entering say \"0.02\" for the \"Isovalue\" and click \"Submit\". If you zoom into a carbon you'll see the wavefunction around it. Unfortunately, since we have the carbon at the origin, this plot is a little hard to see.</p>"},{"location":"labs/extras/labs/visualising_output/readme/#task_1","title":"Task","text":"<ul> <li>In a new directory <code>01_methane_shift</code>, shift the molecule such that the carbon atom is at the centre of the box in the <code>pw.x</code> input file.</li> <li>Run the <code>pw.x</code> and <code>pp.x</code> calculations as before.</li> <li>Visualise the output in <code>xcrysden</code> for the wavefunctions associated with   each of the four bands.<ul> <li>Disable the display of the crystal cell.</li> <li>Try plotting the data grid at different isovalues. Each wavefunction   will have a different range of values that might show interesting   features. You can also try enabling transparency, and increasing the degree of the tricubic cpline to 2 or 3.</li> <li>Under \"Modify\" try reducing the \"Ball Factor\" to reduce the visual size   of the ions.</li> </ul> </li> <li>When you're happy with how it looks, save an image by first checking the   \"File\" -&gt; \"Print Setup\" menu. (You'll need to leave the data grid menu   open). It's usually worth enabling anti-aliasing here. Then go to \"File\" -&gt;   \"Print\" and save the output as a png image.</li> </ul>"},{"location":"labs/extras/labs/visualising_output/readme/#projected-density-of-states","title":"Projected Density of States","text":"<p>Following from the electronic density of states, it can be very useful in understanding a material to visualize how the density of states can be decomposed into the various states belonging to each atom in the system. To do this we can use the <code>projwfc.x</code> tool from the Quantum Espresso package. This is used in a similar way to the <code>dos.x</code> tool, although it is not possible to use tetrahedra to integrate the DOS, so a broadening must be used.</p> <p>A set of example input files for diamond are given in the directory <code>03_projecteddos/01_diamond</code>. This set of inputs follows exactly the same progression as previously, except now for the third step we have an input file for <code>projwfc.x</code> rather than for <code>dos.x</code>. In this file we have a single <code>PROJWFC</code> section, but we have actually retained the same inputs we used previously in the DOS calculation. As usual, you can get full details of the various inputs that are available in the help file <code>INPUT_PROJWFC.txt</code>.</p> <p>Now run these three calculations as before. Again a short script has been provided which does this explicitly. Once they have completed you'll see we again have generated a <code>pwscf.dos</code> file as before. You can try to plot this if you like, and you'll see it's identical to the density of states we obtained with the equivalent <code>dos.x</code> calculation. However, we also have a number of other files that have been generated, all with names beginning with <code>pwscf.pdos_</code> by default. Try looking at <code>pwscf.pdos_tot</code> first. You'll see this is a three column file, with energy, density of states, and the total of the various decomposed projected density of states. In principle column 2 and 3 should be the same (and column 2 will reproduce the already calculated density of states), but in practice it can be difficult to assign conduction band states accurately so there may be some small disagreement there.</p> <p>The additional files will the projected density of states for each atom in the unit cell and each orbital type (s, p, d etc) present. If you look, for example at the file <code>pwscf.pdos_atm#1(C)_wfc#1(s)</code>, you'll see we have three columns: energy, a column labelled <code>ldos</code> and a column labelled <code>pdos</code>. For s-orbitals we only have one value of the magnetic quantum number ml, so there is only one pdos column, and the ldos and pdos columns are equivalent. If you look at the file <code>pwscf.pdos_atm#1(C)_wfc#2(p)</code> you'll see we now have 5 columns: energy, ldos, and 3 pdos columns. ldos gives the sum of the three pdos columns, and each pdos column is for a different value of ml (3 for a p-orbital).</p> <p>In our case, the corresponding files for each of the C atoms in the cell should be equivalent as the two atoms in the cell are equivalent. For one of the atoms, try plotting the projected density of states of the s-orbital and one of the p-orbitals (e.g. try plotting the 3rd column in each file) together. Are the states near the top of the valence band more s-like or p-like?</p>"},{"location":"labs/extras/labs/visualising_output/readme/#task_2","title":"Task","text":"<ul> <li>Calculate and plot, in whichever way you think best shows the important   features and differences, the projected density of states for both silicon   and aluminium.</li> <li>How do these compare to each other, and the example diamond calculation?</li> </ul>"},{"location":"labs/extras/misc/gnuplot/readme/","title":"Plotting with Gnuplot","text":"<p>Gnuplot is a command-line driven open-source plotting utility, with many features such as fitting, and 3D plotting available. You can install it on ubuntu systems by typing <code>sudo apt install gnuplot</code>. The homepage is gnuplot.sourceforge.net, and a detailed manual for the latest release is also available. Gnuplot is also readily scriptable. This allows you, for example, to incorporate it into a bash script to automatically produce a file containing a plot of your results after your calculation has finished.</p> <p>To open gnuplot, simply type <code>gnuplot</code> in a terminal. You will see some information regarding the version of gnuplot that has started, and finally a gnuplot prompt: <code>gnuplot&gt;</code>. You can enter various commands here to generate and save plots.</p> <p>For example: - <code>plot sin(x)</code>     - This will plot the sin function. The x values will range from -10 to +10       by default and the y range will be automatically chosen to be -1 to 1. - <code>plot cos(x), x + 0.1*x**2</code>     - This will plot the cosine function in addition to the function       y=x-0.1*x^2 . - <code>plot \"plot/example.dat\"</code>     - Plots the values listed in the example file <code>plot/example.dat</code>. - <code>set title \"My Results\"</code>     - This sets a title for the plot. - <code>set xrange [-1:1]</code>     - Sets the range of the x-axis in the plot. <code>yrange</code> can be set similarly. - <code>set xlabel \"Position (pm)\"</code>     - Sets the label for the x-axis in the plot. <code>ylabel</code> can be set similarly. - <code>replot</code>     - After changing the plot by e.g. adding a title, it is necessary to redraw       the output plot. The <code>replot</code> command repeats the last plot command.</p>"},{"location":"labs/extras/misc/gnuplot/readme/#outputing-to-a-file","title":"Outputing to a file","text":"<p>To output a plot to for example a pdf file, you need to set the gnuplot \"terminal\" appropriately (the terminal setting determines the type of output generated by gnuplot), set an output filename, and redraw the plot. Typically many different terminals are available which allow ouput to e.g. postscript, png, gif formats.</p> <p>For example, to save a default plot of a sin function to a pdf:</p> <ol> <li><code>set terminal pdf</code></li> <li><code>set output \"sin_plot.pdf\"</code></li> <li><code>plot sin(x)</code></li> </ol>"},{"location":"labs/extras/misc/gnuplot/readme/#fitting","title":"Fitting","text":"<p>We can also define and fit functions within gnuplot. For example, to fit a quadratic to the example data in <code>plot/example.dat</code> we can do the following (here I assume gnuplot has been started from within the <code>plot</code> directory):</p> <ul> <li><code>f(x)=a+b*x+c*x**2</code><ul> <li>This defines the function in terms of a set of parameters.</li> </ul> </li> <li><code>fit f(x) \"example.dat\" via a,b,c</code><ul> <li>This will do a least squares fit, and output the final parameter values   along with standard errors.</li> </ul> </li> <li>Note if no initial values for the parameters are specified, gnuplot will   start each at 1. You can specify initial values before running the <code>fit</code>   command as e.g. <code>a=-1;b=-1;c=0.5</code>. It is particularly important to give good   initial guesses when fitting non-polynomial functions.</li> <li><code>plot \"example.dat\", f(x)</code><ul> <li>This will generate a plot of the data points together with the fit curve.   You can also use this to try to find good initial guesses for parameters   manually when fitting more complex functions.</li> </ul> </li> <li>A summary of the fit results is automatically saved in the file <code>fit.log</code>.</li> </ul>"},{"location":"labs/extras/misc/gnuplot/readme/#scripting","title":"Scripting","text":"<p>One can create scripts as a list of gnuplot commands entered in the same way as would be done manually. Then <code>gnuplot scriptname</code> will execute the script and exit. An example script to perform a quadratic to the data in <code>example.dat</code> and generate a pdf plot of the data compared with the fit is given in <code>plot/example.gpl</code>:</p> <pre><code>f(x)=a+b*x+c*x**2\na=-1;b=-1;c=0.5;\nfit f(x) \"example.dat\" via a,b,c\nset title \"Example Gnuplot Plot\"\nset xlabel \"Position (Bohr)\"\nset ylabel \"Energy (Hartree)\"\nset term pdf\nset output \"example-gp.pdf\"\nplot \"example.dat\" with lines title \"Results\", f(x) title \"Quadratic fit\"\n</code></pre> <p>Try entering the <code>plot</code> directory and running this as <code>gnuplot example.gpl</code>. You will see information on the fit output directly to the terminal, and the files <code>fit.log</code> and <code>example-gp.pdf</code> will be generated. You can view the pdf with the <code>evince</code> document viewer application that is installed by default on ubuntu systems: <code>evince example.pdf</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/","title":"More Useful Linux Commands","text":"<p>While we cover the basic file and navigation commands in Lab 1, There are many more commands that are available as standard on a Linux system that can make your life much easier. In this file we briefly go through some of the more commonly used ones and list a few useful options or potential use cases for each. We'll revisit many of these during the course as they'll help us automate some aspects of running and extracting data from our calculations.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#some-additional-useful-file-commands","title":"Some additional useful file commands","text":"<p>As you are all on the same system and file space is not unlimited, it is good to be aware of how much space you're using. Large calculations can often take more disk space than you might have expected, so it's important to be able to track down large files that are no longer needed if space becomes an issue. The first few commands here can help you with this, beyond using <code>ls -lh</code> to see how big files are.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#df","title":"df","text":"<p><code>df</code> is used to report file system disk space usage for all mounted partitions. This is a useful way to check how much space is free on the disks and partitions used to store files by the system. It also tells you which disks are are real local disks: these are the ones with labels like \"/dev/sda2\" under the filesystem heading, while disks mounted across the network will be labelled with the server address in this field. The \"tmpfs\" label indicates a temporary filesystem, usually this is stored in RAM while the system is running, but can be used through a directory in the file hierarchy.</p> <p>You might notice a remote server directory is mounted to <code>~/homedir</code>. This your windows home directory. You can copy files and folders there if you would like to make the available on your Imperial windows account.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options","title":"Useful Options","text":"<ul> <li><code>df -h</code> will list usage numbers in a human-readable format, i.e. instead of   10240, it would say \"10M\".</li> <li><code>df -T</code> will list the filesystem type e.g. ext3/ext4 for disks using a   typical Linux filestructure, and nfs or cifs for disks mounted remotely over   the network. It is useful to be able to identify filesystems that are   mounted over the network since these are usually slower to use than local   disks if your calculation produces many files. In these cases, if your home   directory is on a remote filesystem you should run your calculation using a   local disk and copy the results to your home directory once it is completed.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#du","title":"du","text":"<p><code>du</code> is used to estimate file space usage. Typing <code>du filename</code> will tell you how big <code>filename</code> is (usually in kB by default). <code>du dirname</code> will tell you how big all the files in directory <code>dirname</code> and its subdirectories are, with a total at the end.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_1","title":"Useful Options","text":"<ul> <li><code>du -s</code> will only print the total size used for the argument. This is   typically used to find how much space a given directory is using.</li> <li><code>du -h</code> will print sizes in human-readable format.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#quota","title":"quota","text":"<p><code>quota</code> is used to check disk usage and limits. Many shared Linux systems, such as HPC systems, and the server you are using for this course, will impose a limit on the disk space used by any individual users. The <code>quota</code> command will tell you what those limits are and how much you have used.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_2","title":"Useful Options","text":"<ul> <li><code>quota -s</code> will show limits and usage in a human-readable format, i.e.   instead of 3145180 it would say 3072M.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#head-and-tail","title":"head and tail","text":"<p><code>head</code> outputs the first few lines of a file to the terminal, while <code>tail</code> outputs the last few lines of a file to the terminal.</p> <ul> <li><code>head filename</code> outputs the first 10 lines of <code>filename</code>.</li> <li><code>head -5 filename</code> outputs the first 5 lines of <code>filename</code>.</li> <li><code>tail filename</code> outputs the last 10 lines of <code>filename</code>.</li> <li><code>tail -5 filename</code> outputs the last 5 lines of <code>filename</code>.</li> <li><code>tail -f filename</code> starts tail in \"follow\" mode, where tail will repeatedly   check for new data written to the file, and output them to the terminal.   This is useful for following the output from a running calculation for   example.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#chmod","title":"chmod","text":""},{"location":"labs/extras/misc/linuxcommands/readme/#permissions","title":"Permissions","text":"<p>If you take a look at the output of <code>ls -l</code> you'll see the first column has a mix of letters (usually d, r, w, x, and hyphens).</p> <ul> <li>The first character in this column indicates the file: <code>d</code> for directories,   and <code>-</code> for regular files.</li> <li>The following nine characters indicate the permissions. These are in sets of   three where each set indicates the permission for a set of users.<ul> <li>The first set of three characters are the permissions for the user that   owns the file (listed in the third column).</li> <li>The second set of three characters are the permissions of other members   of the group that own the file (listed in the fourth column).<ul> <li>The default on many Linux systems is to create a group of the same     name as the username, that contains only that user.</li> <li>It's also possible for users to be added to several groups     by the system administrator. This is useful on shared systems     where a certain set of users want to share access to some set of     files, but without giving access to everyone.</li> <li>You can see what groups you are in by typing <code>groups</code> in the     terminal.</li> </ul> </li> <li>The third set of three characters are the permissions for all other   users.</li> </ul> </li> <li>Within each set of three characters:<ul> <li>The first character is \"r\" if users in that set have permission to read   the file and \"-\" otherwise.</li> <li>The second character is \"w\" if users in that set have permission to write   to the file and \"-\" otherwise.</li> <li>The third character is \"x\" if users in that set have permission to   exectute to the file, i.e. run it as a program.</li> </ul> </li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#chmod-command","title":"chmod command","text":"<p><code>chmod</code> can be used to change file permissions. This command can be invoked in two different ways:</p> <p>One can change the permission for a given set of users granularly: - <code>chmod u+x filename</code> grants the user who owns the file execute permission.   This is one of the main things you will be using <code>chmod</code> for as when you   create a script in a text editor it will not be executable by default. - <code>chmod g+rw filename</code> grants group members read and write permission. - <code>chmod o-r filename</code> revokes other users read permission. - <code>chmod a+x filename</code> grants all users execute permission.</p> <p>One can use a set of three numbers to set the full list of permissions at once. What each number corresponds to is listed in following table:</p> # Permission rwx 7 read, write and execute rwx 6 read and write rw- 5 read and execute r-x 4 read only r-- 3 write and execute -wx 2 write only -w- 1 execute only --x 0 none --- <ul> <li>To set the permissions of a directory so only the owner can access it in any   way you could use <code>chmod 700 directoryname</code>.</li> <li>To set a script you have created so that others can use and execute it you   could use <code>chmod 755 scriptname</code>.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#wc","title":"wc","text":"<p><code>wc filename</code> will output the newline, word and byte counts for <code>filename</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_3","title":"Useful Options","text":"<ul> <li><code>-l</code> to output the number of lines in the file.</li> <li><code>-w</code> to output the word count for the file.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#grep","title":"grep","text":"<p><code>grep</code> will print lines from a file or stdin which match a given pattern.</p> <ul> <li><code>grep searchtext filename</code> will output all lines in <code>filename</code> which contain   the text <code>searchtext</code>.</li> <li><code>history | grep less</code> will output all lines in the command history containing   <code>less</code>. This is useful for those times when you entered a complex command   some time ago that you want to repeat it.</li> </ul> <p>While <code>searchtext</code> in the first example above could be a particular word you want to find an exact match of, <code>grep</code> will also interpret this as a regular expression by default. This is somewhat similar to the wildcards you can use in the terminal, but has a slightly different syntax and allows for much more complex patterns.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#regular-expressions","title":"Regular Expressions","text":"<p>This is a very deep topic, so we'll only cover a few of the more simple examples. <code>man grep</code> has significantly more detail. The most useful symbols are probably:</p> <ul> <li><code>.</code> matches any single character.</li> <li><code>*</code> the preceding item will be matched zero or more times.</li> <li>These are quite useful when combined to form <code>.*</code>, which acts in the same way   as the terminal wildcard expression <code>*</code>.</li> <li>Note: to match the actual <code>.</code> or <code>*</code> symbols, you can escape them as <code>\\.</code> and   <code>\\*</code>.</li> </ul> <p>For example <code>grep \"doc.*\\.pdf\" dirfiles.dat</code> will output all lines containing strings that begin with <code>doc</code> and end with <code>.pdf</code>.</p> <p>Note regular expressions can also be used in <code>less</code> (and hence <code>man</code>) when searching for text with <code>/</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_4","title":"Useful Options","text":"<ul> <li><code>grep -3 searchtext filename</code> will additionally output 3 lines before and   after any lines containing <code>searchtext</code>. Any number of lines can be used   here.</li> <li><code>grep -v searchtext filename</code> will output all lines except those containing   <code>searchtext</code>.</li> <li><code>grep -r searchtext</code> will recursively search all files and folders starting   from the current directory.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#cut","title":"cut","text":"<p><code>cut</code> prints selected parts from each line a file. Mostly this is used with the <code>-f</code> option which tells it to print only certain fields, and the <code>-d</code> option which allows you to set the delimiter for fields (TAB is the default). It is often useful to pipe (<code>|</code>) the output of <code>grep</code> into <code>cut</code> to parse data from an output file.</p> <p>For example, <code>cut -d ' ' -f 1 filename</code> will print the first word (separated by spaces) on each line of <code>filename</code>, and <code>cut -d ',' -f '3-5' data.csv</code> would print the 3rd, 4th and 5th columns of a csv data file.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_5","title":"Useful Options","text":"<ul> <li><code>-s</code> tells <code>cut</code> not to output lines which do not contain delimiters. This is   useful for example if you have empty lines in the file you are parsing that   you want to suppress.</li> <li><code>--complement</code> will output the complement of the selected fields. For   example, if we had a 5 column csv data file, <code>cut -d ',' -f '2-4'   --complement</code> would output the 1st and 5th columns.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#awk","title":"awk","text":"<p><code>awk</code> is a pattern scanning and processing language. It is typically used to parse files in a similar manner to using <code>grep</code> combined with <code>cut</code>. <code>awk</code> is very powerful but we will only cover some very basic operations.</p> <ul> <li><code>awk '/regexp/{print}' filename</code> will output all lines in <code>filename</code>   containing <code>regexp</code>. As with <code>grep</code>, regular expressions can be used in   <code>regexp</code>.</li> <li><code>awk '/regexp/{print $1\" \"$3}' filename</code> will output the first and third   words in all lines containing <code>regexp</code>. Note by default <code>awk</code> uses spaces as   the field delimiter.</li> <li><code>awk 'BEGIN{i=0} /regexp/{i=i+1} END{print i}' filename</code> will output the   number of lines in <code>filename</code> containing <code>regexp</code>.</li> <li><code>awk '/searchtext/{printf \"%f %f\\n\",$2-13.0,$4*10.0}' filename</code> will output   for each line containing <code>searchtext</code>, the second field with 13.0 subtracted,   and the fourth field times 10.</li> </ul> <p>Hopefully these examples give you an idea of what is possible with <code>awk</code>. More details and examples can be found with <code>man awk</code>.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_6","title":"Useful Options","text":"<ul> <li><code>-F</code> allows you to set the field separator. For example <code>awk -F','</code> would be   useful for parsing a csv file.</li> <li><code>-f program-file</code> tells <code>awk</code> to run the commands listed in <code>program-file</code>.   This is useful if you have a complicated script so you don't need to type it   all in directly to the terminal.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#sed","title":"sed","text":"<p><code>sed</code> stands for stream editor. It allows you to perform basic text transformations on a file (or from stdin). <code>sed</code> is very powerful and we will only cover some very simple examples.</p> <ul> <li><code>sed 's/regexp/replacement/' filename &gt; newfile</code> will replace the first match   of <code>regexp</code> on each line of <code>filename</code> with <code>replacement</code>. Here the first <code>s</code>   stands for substitute, and is probably the most useful sed command. Note that   <code>sed</code> outputs to stdout by default, so you should redirect this to a new   file to save. Do not try to redirect output to the same file you are   reading, as <code>&gt;</code> will blank the file before <code>sed</code> can read anything from it.<ul> <li><code>sed 's/^...//' filename &gt; newfile</code> will remove the first three   characters from every line of <code>filename</code>. Note <code>^</code> is used to match the   beginning of a line.</li> </ul> </li> <li><code>sed 's/regexp/replacement/g' filename &gt; newfile</code> will replace every match   of <code>regexp</code> on each line of <code>filename</code> with <code>replacement</code>.<ul> <li><code>sed 's/,/\\t/g' data.csv &gt; data.dat</code> would replace all commas with tabs   (<code>\\t</code> is a tab) in <code>data.csv</code> and save it in <code>data.dat</code>.</li> </ul> </li> <li>The <code>-i</code> flag can be used to modify a file in-place.   <code>sed -i 's/regexp/replacement/g' filename</code> will replace every match of   <code>regexp</code> on each line of <code>filename</code> with <code>replacement</code>. <code>filename</code> itself   will be modified. You can also specify a suffix here such that a backup   will be created using that suffix: e.g.   <code>sed -i.bak 's/regexp/replacement/g' filename</code> will do the replacement in-place   but first backup the original file to <code>filename.bak</code>.</li> </ul> <p>See <code>man sed</code> for more information.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#tr","title":"tr","text":"<p><code>tr</code> is used to translate or delete characters. It always reads from stdin, and outputs to stdout. This means that to use it with a file, we need to redirect the file to stdin using <code>&lt;</code>.</p> <ul> <li><code>tr 1 2 &lt; test.dat</code> would output the contents of <code>test.dat</code> with all the 1s   replaced by 2s.</li> <li><code>tr abc ABC &lt; test.txt</code> would output the contents of <code>test.txt</code> with any 'a'   replaced by 'A', 'b' by 'B' and 'c' by 'C'.</li> </ul> <p>It also accepts some special input such as</p> <ul> <li><code>[:space:]</code> to match whitespace (both single and continuous).</li> <li><code>[:punct:]</code> to match punctuation</li> <li><code>[:lower:]</code> to match lower case letters</li> <li><code>[:upper:]</code> to match upper case letters</li> </ul> <p>For example:</p> <ul> <li><code>tr [:lower:] [:upper:] &lt; test.txt &gt; test_upper.txt</code> would to create a new   version <code>test.txt</code> converted to uppercase.</li> <li><code>tr [:space:] '\\n' &lt; test.txt</code> would convert all spaces to newlines.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_7","title":"Useful options","text":"<ul> <li><code>-d</code> deletes matching characters. For example, to output a file with all   punctuation removed we could do <code>tr -d [:punct:] &lt; test.txt</code></li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#find","title":"find","text":"<p><code>find</code> is used to search for files in a directory hierarchy. Most commonly this is used with the <code>-name</code> option to search for files with a particular name. Wildcards can be used in the search. Note: the first argument to <code>find</code> should be the path to search, e.g. <code>find /etc</code> to search for files in the <code>/etc</code> directory or <code>find .</code> to search for files in the current directory.</p> <ul> <li><code>find . -name \"*.cpp\"</code> will find all files ending in <code>.cpp</code> in the current   directory (<code>.</code>) and its subdirectories.</li> </ul> <p>See <code>man find</code> for more information.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#diff","title":"diff","text":"<p><code>diff</code> is used to compare two files. This is useful if for example, you want to see what changes have been made in a new version of a file.</p> <ul> <li><code>diff file1 file2</code> will output the lines which differ between the two files.   The lines from <code>file1</code> will be prepended with <code>&lt;</code> and the lines from <code>file2</code>   with <code>&gt;</code>.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_8","title":"Useful Options","text":"<ul> <li><code>-q</code> will report only whether the two files differ and will not output the   differences.</li> <li><code>-r</code> will recursively compare files in subdirectories.</li> <li><code>-y</code> will output the two files side by side in two columns.</li> <li><code>-W</code> will allow you to set how wide the output is (130 columns by default).   This is particularly useful with the <code>-y</code> option.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#sort","title":"sort","text":"<p><code>sort</code> is used to sort lines of text files. For example, if we had a file called <code>users.txt</code> which contained a list of names, then <code>sort users.txt</code> would output (to stdout) the list sorted alphabetically. This is often useful combined with other commands. For example to generate a sorted list of all words in a file you can do <code>sed 's/ /\\n/g' filename | sort</code>. Here the <code>sed</code> command replaces all spaces with new lines, so we have one word per line, and then we use this as input to the sort command.</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_9","title":"Useful Options","text":"<ul> <li><code>-n</code> will sort numerically rather than alphabetically. For example,   <code>du -s * | sort -n</code> will generate a listing of files and directories sorted   by size.</li> <li><code>-h</code> will use a human numeric sort, allowing numbers such as 2K and 1G to be   sorted. For example, <code>du -sh * | sort -h</code> will generate a listing of files   and directories sorted by size, but in human readable format.</li> <li><code>-u</code> will output only the first of an equal run. For example   <code>sed 's/ /\\n/g' filename | sort -u</code> will generate a sorted list of all words   in <code>filename</code> with each listed only once.</li> <li><code>-f</code> will till <code>sort</code> to fold lower case to upper case characters.</li> <li><code>-r</code> will output in reverse order. This is useful for numeric sorts where you   often want to have the largest numbers at the top.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#uniq","title":"uniq","text":"<p><code>uniq</code> is used to report or omit repeated lines in a file. By default it will take any file or input from stdin, and output it with duplicated lines omitted. For example if we had a text file <code>test.txt</code> with</p> <pre><code>a\na\nb\nb\nb\nc\nd\nd\n</code></pre> <p>Running <code>uniq test.txt</code> would output</p> <pre><code>a\nb\nc\nd\n</code></pre>"},{"location":"labs/extras/misc/linuxcommands/readme/#useful-options_10","title":"Useful Options","text":"<ul> <li><code>-c</code> prefixes each line of output with a count of its number of occurrences.   We could for example, take the <code>sort</code> example to sort all words in a file,   and expand it to generate a word count of all words in a file:   <code>sed 's/ /\\n/g' filename | sort | uniq -c</code>. We could add <code>| sort -n</code> to the   end of this to sort words in order of frequency, and we could use <code>tr</code> before   this to remove all punctuation.</li> <li><code>-i</code> tells <code>uniq</code> to ignore differences in case when comparing.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#tar","title":"tar","text":"<p><code>tar</code> is an archiving utility used to create an archive of files, i.e. generate a file containing many other files. This is usually used to create compressed bundles of files on Linux, in a similar way to zip file archives (note zip and unzip are usually available on Linux also, but compressed tar archives are more commonly used).</p>"},{"location":"labs/extras/misc/linuxcommands/readme/#creating-archives","title":"Creating Archives","text":"<p>The <code>-c</code> flag indicates to <code>tar</code> that you want to create an new archive.</p> <ul> <li><code>tar -cvf archive.tar file1 file2 dir1</code> will create an (uncompressed) archive   called <code>archive.tar</code> of the named set of files or directories. Here:<ul> <li><code>-v</code> is for verbose mode - it will list the files which are added. This   is not really necessary, but is useful so you can be sure you are adding   the files you intended to.</li> <li><code>-f</code> is used to specify the archive name. Here we have called it   <code>archive.tar</code>.</li> </ul> </li> <li><code>tar -czvf archive.tar.gz file1 file2 dir1</code> uses the additional <code>-z</code> flag to   compress the archive using <code>gzip</code> compression. The extension <code>.tar.gz</code> or   <code>.tgz</code> is typically used to indicate this type of file. Several other   possible compression algorithms could be used instead:<ul> <li><code>-j</code> will use <code>bzip2</code> compression. This typically results in slightly   smaller file size than <code>gzip</code>, but can take slightly longer. Files   created like this usually use the extension <code>.tar.bz</code> or <code>.tbz</code> or some   other similar variation.</li> <li><code>-J</code> will use <code>xz</code> compression. This is a very effective compression   algorithm, resulting in very small files, particularly for archives   containing a lot of text. This option can take quite a lot longer than   gzip for large archives however. Files created with this option usually   use the extension <code>.tar.xz</code> or <code>.txz</code>.</li> </ul> </li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#extracting-archives","title":"Extracting Archives","text":"<p>The <code>-x</code> flag indicates to <code>tar</code> you want to unpack an archive.</p> <ul> <li><code>tar -xvf archivename</code> will uncompress and unpack a tar archive called   <code>archivename</code>, automatically detecting what kind of compression was used (if   any). Again the <code>-v</code> isn't necessary, but is useful.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#listing-archive-content","title":"Listing Archive Content","text":"<p>The <code>-t</code> flag will tell <code>tar</code> to list the contents of an archive.</p> <ul> <li><code>tar -tvf archivename</code> will list the contents of the tar archive   <code>archivename</code>, again automatically detecting what kind of compression was   used.</li> </ul>"},{"location":"labs/extras/misc/linuxcommands/readme/#bc","title":"bc","text":"<p><code>bc</code> is an arbitrary precision calculator language. This can be used from the command line by piping expressions to it. For example:</p> <ul> <li><code>echo \"2+2\" | bc</code></li> <li>For floating point operations, you should set the scale which defines how   many digits following the decimal points are output:</li> <li><code>echo \"scale=10; 1.412*27.211\" | bc</code></li> <li><code>echo \"scale=10; sqrt(2)\" | bc</code></li> <li>You can tell bc to load the standard math library with the <code>-l</code> flag. This   will also set the scale to 20 by default. This makes several additional   functions available such as <code>s(x)</code>, <code>c(x)</code> and <code>a(x)</code> for the sine, cosine   and arctan in radians. So <code>echo \"4*a(1)\" | bc -l</code> will output the first 20   decimal places of pi.</li> </ul>"},{"location":"labs/extras/misc/running_in_parallel/readme/","title":"Running in Parallel","text":"<p>All modern DFT codes are capable of running in parallel, provided they have been compiled to do so. While you may be familiar with a single application using several threads when you start it so that it runs faster, the parallelisation scheme used by many DFT codes allows them to run on a large number of different machines simultaneously to complete a single DFT calculation.</p> <p>In the quantum espresso package, this is achieved through the use of MPI in which a number of copies of a program are started at the same time which can then pass information among themselves, communicating over the network or faster interfaces such as infiniband, or running several on the same machine where they each use a single core (or possible more than one, as each process could in principle use several threads also). So a calculation that takes say 10 minutes without using any parallelization, would take (slightly more than) around 5 minutes using two parallel processes.</p> <p>Throughout the course material, we make no mention of running in parallel. This is just for simplicity, since it's one less thing for you (and me) to worry about in the labs. The calculations we have you do in the labs and homework assignments are small enough that this isn't necessary, but if you're interested in doing more serious DFT calculations such as for a MSc project then you should certainly start running your calculations in parallel.</p>"},{"location":"labs/extras/misc/running_in_parallel/readme/#getting-a-version-of-espresso-that-can-run-in-parallel","title":"Getting a version of espresso that can run in parallel","text":"<p>If you're on one of the mt-student servers, there is a separate module for quantum-espresso compiled with parallel features enabled called <code>espresso-mpi</code>. To load this, you'll also need to have the <code>openmpi</code> module loaded first. It is set to conflict with the <code>espresso</code> module, so it will generate an error if you try to load it while you have that loaded; if so you can first unload that with <code>module unload espresso</code>.</p> <p>To load the parallel module on an mt-student server type <code>module load gcc   mkl openmpi espresso-mpi</code></p> <p>If you have installed a VM on your laptop for this course, and have installed quantum-espresso from Ubuntu repositories (e.g. via <code>apt</code>), this version already has parallel features enabled.</p>"},{"location":"labs/extras/misc/running_in_parallel/readme/#running-your-calculation-in-parallel","title":"Running your calculation in parallel","text":"<p>There are several ways to start a parallel calculation, and if you're using some HPC service, you such check their documentation for their recommended approach.</p> <p>To start a parallel calculation on mt-student or your own VM you can do the following:</p> <ul> <li>Use the <code>mpirun</code> command, which is used to start a program that has been   compiled with MPI enabled communication (if you run it on a normal program   it will simply start several copies of that program at the same time).</li> <li>To tell it how many processes you want to start, you give it the <code>-np</code> flag   followed by a number, such as <code>-np 2</code> to start two parallel processes.</li> <li>Then give it your program and input and output as usual.</li> </ul> <p>Say for example, we have an input for a silicon calculation for <code>pw.x</code> called <code>Si.in</code> and we want to save the output in <code>Si.out</code>:</p> <ul> <li>For the serial (non-parallel) calculation we would write   <code>pw.x &lt; Si.in &amp;&gt; Si.out</code></li> <li>For a parallel calculation, if we wanted to use two parallel processes,   we would write <code>mpirun -np 2 pw.x &lt; Si.in &amp;&gt; Si.out</code>.</li> </ul> <p>The majority of the codes that come with the quantum espresso package can run in parallel in this manner.</p> <p>You should be aware however, that planewave DFT calculations don't scale linearly. Your calculation will get faster to a certain point, after which if you add more parallel processes you'll slow your calculation down. This can vary depending on the system and type of calculation you're doing, but usually you'll see a reduction up to around 50 processes depending on the parallelisation scheme (see below) and system involved.</p>"},{"location":"labs/extras/misc/running_in_parallel/readme/#types-of-parallelisation","title":"Types of parallelisation","text":"<p>If we do the above and write <code>mpirun -np 2 pw.x &lt; Si.in &amp;&gt; Si.out</code>, we accept the default strategy for parallelising the calculation. Different DFT codes use different defaults, which all have their own advantages and disadvantages. Using the default for quantum espresso is generally pretty good. The differences between the different schemes are discussed in detail in the quantum espresso documentation for <code>pw.x</code> but in general a planewave DFT code can be parallelised in the following ways (which can be used in combination provided this has been implemented):</p> <ul> <li>Over sets of calculations - if the calculation you have asked for involves   running several similar calculations automatically, you can break up these   calculations between your parallel processes. Quantum espresso offers this   functionality for some types of calculations (such as for phonons) and   refers to these sets as images.<ul> <li>You can set how many of these are used for a parallel calculation with   <code>-nimage</code> or <code>-ni</code>. If you run with 20 processors and specify <code>-ni 2</code>,   each image will use 10 processors. The default is 1.</li> </ul> </li> <li>Over k-points - this scheme needs very little communication between   processes and so offers very good scaling, as each k-point can be treated as   effectively a separate calculation where results are added together at the   end. It doesn't do as much as other schemes to reduce the memory   requirements of the calculation, and if your calculation doesn't use many   k-points, or you're calculating a molecule this may be a limited approach.<ul> <li>You can set how many parallel groups of k-points your calculation uses   with the <code>-npools</code> or <code>-nk</code> flags in quantum espresso. The default is   1.</li> </ul> </li> <li>Over bands - This can cut down the amount of memory used by each process but   requires a bit more communication between processes.<ul> <li>You can set how groups of bands are used for parallelising your   calculation with the <code>-nband</code> or <code>-nb</code> flags. The default is 1.</li> </ul> </li> <li>Over planewaves (FFT planes) - the plane wave basis set can be distributed   across parallel processes. Quantum espresso does this very efficiently and   this is its default parallelisation scheme. It will distribute planes of 3D   FFT points to the parallel processes.<ul> <li>This is always turned on. Whatever the number of parallel processes that   are left over after you specify other options will be used in this   manner.</li> </ul> </li> <li>Over task groups - if you have more parallel processes than FFT grid planes,   you can redistribute the FFTs into task groups that allows for more   efficient processing.<ul> <li>You can set the number of task groups with the <code>-ntg</code> or <code>-nt</code> flags.   The default is 1.</li> </ul> </li> </ul> <p>There is also an overview of the options for the various quantum espresso packages at https://www.quantum-espresso.org/Doc/user_guide/node18.html if you'd like more detail.</p>"},{"location":"labs/extras/misc/shellscripting/readme/","title":"Bash and Shell Scripting","text":""},{"location":"labs/extras/misc/shellscripting/readme/#bash-shell","title":"Bash Shell","text":"<p>There are often several different shells installed on a Linux system. <code>bash</code> is probably the most common, and is typically the default for new users on any system. <code>bash</code> is running in the terminal, and it interprets and executes the commands we type in.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#environment","title":"Environment","text":""},{"location":"labs/extras/misc/shellscripting/readme/#user-configuration","title":"User Configuration","text":"<p>On startup, such as when a new terminal is opened, or you connect to a remote system over the network, <code>bash</code> will read several configuration files depending on how it detects it is running.</p> <ul> <li>For login shells (shells where you are prompted to login when you start it),   <code>bash</code> will read configuration options in <code>~/.bash_profile</code> or <code>~/.profile</code>   if these exist. Note <code>~</code> is interpreted by the shell as the users home   directory.</li> <li>For non-login shells (such as when you open the terminal emulator) <code>bash</code>   will read configuration options in <code>~/.bashrc</code>.</li> <li>A lot of the time, for simplicity, many people will put all their   configuration options in <code>~/.bashrc</code> and leave their <code>~/.profile</code> empty   except for a command to read the <code>~/.bashrc</code> file.</li> </ul> <p>These files can be used to configure many aspects of the shell, such as how the prompt looks in the terminal.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#environment-variables","title":"Environment Variables","text":"<p>Many important aspects of how <code>bash</code> behaves are governed by environment variables. These can be modified to your preference in your configuration files. To see the current value of one of these variables you can do, e.g. <code>echo $PATH</code>. A <code>$</code> symbol is used when referring to the data stored in a variable, and <code>echo</code> is a built-in bash command that outputs something to the terminal.</p> <ul> <li><code>PATH</code>: this tells bash which directories to look in for executables so they   can be run without typing in their full path. For example, we can just type   in <code>gedit</code> in the terminal to launch the program, as the <code>PATH</code> variable   contains the directory holding an executable of this name. Different   directories are separated by \":\".<ul> <li>To add the directory <code>~/.bin</code> to your path, you can add the line   <code>export PATH=\"~/bin:$PATH\"</code> to the <code>.bashrc</code> file. Here the <code>export</code>   statement is used to allow the variable to be usable by any child   processes rather than local to the script. Note when we are naming the   variable we want to assign a value to we don't use a <code>$</code>. Also we just   want to add a directory to the existing <code>PATH</code> so we add <code>:$PATH</code> to keep   all the existing directories.</li> </ul> </li> </ul>"},{"location":"labs/extras/misc/shellscripting/readme/#scripting","title":"Scripting","text":"<p>Shell scripts allow you easily string together sets of commands in a useful way. For example, you could write a script that runs a calculation, parses the important results to another file, and then generates a plot.</p> <p>This course will only be able to briefly cover scripting. If you're interested in developing more advanced scripts, I strongly suggest referring to the Advanced Bash-Scripting Guide.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#the-basics","title":"The basics","text":"<p>A simple example script to output \"Hello World!\" is as follows:</p> <pre><code>#!/bin/bash\n# Simple example script that outputs \"Hello World!\"\n\necho \"Hello World!\"\n</code></pre> <ul> <li>The first line tells the system what command is used to interpret the   contents of the script. This line should always begin with <code>#!</code> and then the   path to the executable. For <code>bash</code> the executable will almost always be   <code>/bin/bash</code>.</li> <li>Comments being with <code>#</code>.</li> <li>Commands can be entered otherwise as you would enter them to the terminal.</li> <li>Try creating a file called <code>hello.sh</code> with the contents listed above.</li> <li>You will need to make the script executable with <code>chmod u+x hello.sh</code>.</li> <li>Then you can run it by typing <code>./hello.sh</code>.</li> </ul>"},{"location":"labs/extras/misc/shellscripting/readme/#variables","title":"Variables","text":"<p>Variables don't need to be declared in any way, you can assign a value and start using them. For example:</p> <pre><code>#!/bin/bash\n# Example using variables.\n\nvar1=\"Hello\"\nvar2=\"World!\"\n\necho $var1 $var2\n# Note the use of the $ symbol when we want to use the value stored in the\n# variable.\n\n# Any command can use these variables\ndirname=\"tmpdir\"\nmkdir $dirname\n</code></pre> <p>You can also read a value from stdin using the <code>read</code> command as follows:</p> <pre><code>#!/bin/bash\n# Example showing how the read command is used.\n\necho \"Please enter some text:\"\nread user_text\n\necho \"The text you entered was:\" $user_text\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#capitalization","title":"Capitalization","text":"<p>Note: variable names are case sensitive in bash. The usual convention used is that environment variables (such as <code>PATH</code>), and internal shell variables (such as <code>BASH_VERSION</code>) are capitalized, while other variables are in lowercase. Adopting this convention will ensure that you don't accidentally overwrite any important variables in your scripts.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#command-substitution","title":"Command Substitution","text":"<p>Command substitution allows the result of a command to replace the command itself, acting much like a variable in practice. For example:</p> <pre><code>#!/bin/bash\n# Example of command substitution.\n\n# This can be done by enclosing the command in $( )\necho \"It is now $(date).\"\n# Note: the \"date\" command outputs the current date and time.\n\n# This can also be done by enclosing the command in backtics ` `\necho \"The files in this directory are:\" `ls`\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#conditional-statements","title":"Conditional Statements","text":"<p><code>if</code> statements can be used in bash, and many types of tests are possible. You can test if the value stored in a variable equals something as follows:</p> <pre><code>#!/bin/bash\n# Example using if statatements\n\necho \"Please enter a yes or no: \"\nread user_response\n\n# Note the spaces following `[` and before `]` are important.\nif [ $user_response = yes ]\nthen\n    echo \"You entered yes.\"\nelif [ $user_response = no ]\n# \"elif\" is the same as \"else if\"\nthen\n    echo \"You entered no.\"\nelse\n    echo \"You didn't enter yes or no.\"\nfi\n# \"if\" statements are always ended with \"fi\".\n</code></pre> <p>We can also check, e.g., if a file or directory exists:</p> <p><pre><code>#!/bin/bash\n# Check if the directory \"tmpdir\" exists, and if not, create it, then check\n# if the file \"tmpdir/testfile\" exists, and if not, create it.\n\ndirname=\"tmpdir\"\nfilename=\"testfile\"\n\nif [ ! -d \"$dirname\" ]\n# The \"!\" is logical negation\n# -d tests that a file exists and is a directory.\nthen\n    mkdir $dirname\nfi\n\nif [ ! -f \"$dirname/$filename\" ]\n# -d tests that a file exists and is a regular file (i.e. not a directory).\nthen\n    touch \"$dirname/$filename\"\nfi\n</code></pre> Many other tests of this form are possible.</p> <p>Note, bash can also use the <code>[[ ... ]]</code> test construction rather than <code>[ ... ]</code>, with the former offering some more options and functioning more like other programming languages, though it won't work in many other (non-bash, or older bash version) shells.</p>"},{"location":"labs/extras/misc/shellscripting/readme/#arithmetic-and-testing","title":"Arithmetic and Testing","text":"<p>To test numeric values, the <code>(( ... ))</code> construction can be used. For example:</p> <pre><code>#!/bin/bash\n# Example showing the use of the (( )) construction\n\nvar1=4\nvar2=5\nvar3=8\n\nif (( var1 + var2 &gt; var3 ))\n# Note within the (( )) don't use $ symbols before variables.\nthen\n    echo \"$var1 + $var2 &gt; $var3\"\nelse\n    echo \"$var1 + $var2 &lt;= $var3\"\nfi\n\n# We can also use the construction to perform basic arithmetic\nvar4=$(( var1 * var3 ))\necho \"$var1 * $var3 = $var4\"\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#for-loops","title":"For Loops","text":"<p>For loops iterate a variable over a range of values. For example: <pre><code>#!/bin/bash\n# Simple for loop example.\n\n# This construction loops over a space separated list of values. A variable\n# whose contents contains spaces would work in the same way.\nfor i in 1 2 3\ndo\n    echo \"Iteration number $i\"\ndone\n</code></pre></p> <p>A for loops can be used to apply a command repeatedly to a set of files. For example:</p> <pre><code>#!/bin/bash\n# Example showing a simple for loop over a list of arguments used to convert\n# a set of data files with comma separted columns to tab separated columns.\n\nfor csvfile in \"$(ls *.csv)\"\ndo\n    datfile=\"$(basename $csvfile .csv).dat\"\n    # basename is a tool to strip the suffix from a file. Here we use it\n    # to construct a new filename with the .dat extenstion.\n    sed 's/,/\\t/g' $csvfile &gt; $datfile\ndone\n</code></pre> <p>Bash also supports numeric loop ranges using the syntax <code>{start..finish..increment)</code>. For example</p> <pre><code>#!/bin/bash\n# Example of for loop with numeric increments\n\nfor i in {0..6..2}\ndo\n    echo \"The value of i is $i\"\ndone\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#while-loops","title":"While Loops","text":"<p>Bash also supports while loops, where a set of commands are repeated continuously while a given condition is true. For example:</p> <pre><code>#!/bin/bash\n# Example of while loop in bash\n\ncounter=0\n\n# Here -lt means less than\nwhile [ $counter -lt 10 ]\ndo\n  echo $counter\n  counter=$((counter + 1))\ndone\n</code></pre> <p>It is often convenient to use <code>while</code> loops to operate on every line of a file. For example:</p> <pre><code>#!/bin/bash\n# Example of while loop reading lines from a file\n\nlinenumber=0\n\nwhile read line\ndo\n  linenumber=$((linenumber + 1))\n  echo \"$linenumber: $line\"\n  # This will prepend each line of a file with its line number.\ndone &lt; test.txt\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#arguments","title":"Arguments","text":"<p>We can also pass arguments to bash scripts from the command line. For example:</p> <pre><code>#!/bin/bash\n# Example using command line arguments. Call this script with several\n# arguments.\n\necho \"The first argument is $1\"\necho \"The second argument is $2\"\necho \"The number of arguments is $#\"\necho \"The full list of arguments is $@\"\n</code></pre> <p>We can loop over arguments using a for loop as follows:</p> <pre><code>#!/bin/bash\n# Example using a for loop to iterate over command line arguments.\n\nfor arg in $@\ndo\n  echo $arg\ndone\n</code></pre>"},{"location":"labs/extras/misc/shellscripting/readme/#functions","title":"Functions","text":"<p>We can also define functions in bash as we would in other languages. These allow sections of code to be reused as needed and can help make a script easier to follow.</p> <p>A simple example is as follows: <pre><code>#!/bin/bash\n# Simple example of a function in a bash script\n\n# First we define a function called \"hello\", that will output \"Hello World!\"\n# when called.\nhello() {\n  echo \"Hello World!\"\n}\n\n# To call the function, we just use its name.\n# Note function names in the script will take precedence over executable names\n# from the path in the script.\nhello\n</code></pre></p>"},{"location":"labs/extras/misc/vmsetup/readme/","title":"Setting up the necessary software in a virtual machine","text":"<p>Note</p> <p>If you are an MSE404 student you do not need to follow the instructions given here. </p> <p>These instructions are only for people who wish to run their own copy of the software on their own machine. Doing is only recommended for more advanced users or people without access to the compute server. It will mean many files will not be at the location given in the lab documents so you will need to be able to modify the instructions correctly yourself.</p> <p>A virtual machine allows you to run a complete operating system contained within an application regardless of what operating system you have. One package that allows you to do this is VMWare. VMWare is available free to Imperial College students via http://www.imperial.ac.uk/admin-services/ict/store/software/software-for-students/.</p> <p>Once you have it installed this, I suggest getting an Xubuntu iso from https://xubuntu.org/getxubuntu, and using this to create a new virtual machine. You can go with all the default settings, and pick whatever username and password you like.</p> <p>Once this is complete, it should reboot and prompt you for the password you set during install to log you in to your desktop. Then first ensure the system is fully up-to-date with</p> <p><pre><code>sudo apt-get update\nsudo apt-get upgrade\n</code></pre> You may also prefer to change the keyboard settings, since it defaults to a US layout. If you go to the settings menu and pick \"Language Support\" you can drag e.g. \"English (United Kingdom)\" to the top of the list and click the \"Apply System-Wide\" button. You may also want to go to the \"Regional Formats\" tab and select the UK option and apply system wide again. Then go to the Keyboard settings menu and the \"Layout\" tab. At the bottom, click the \"Add\" button and scroll down to UK English (there are several sub-options here that may be better if you have e.g. a Mac). You can delete the US layout once you have added the UK one.</p> <p>Then you can simply install quantum espresso from the repositories, with</p> <pre><code>sudo apt-get install quantum-espresso\n</code></pre> <p>This will install a slightly older version of quantum espresso (which still has all the features needed for these labs but may output additional files, such as the wavefunction in a slightly different place than mentioned in the lab description), and will not however create some of the directories, and help files that we use in the examples. So some of the commands given in the lab documents will not work without modification by you by default. In particular, you should skip the various <code>module</code> commands as they will not be necessary for you.</p>"},{"location":"labs/extras/misc/vmsetup/readme/#if-you-have-access-to-the-server","title":"If you have access to the server","text":"<p>One way around this, if you have access to the server, would be be to copy these directories to the same place on your virtual machine. You can do this by connecting to the college VPN and using the following commands, substituting your college username for USER in the second command (which will also prompt you for your college password):</p> <pre><code>sudo mkdir -p /opt/share\nsudo rsync -auz USER@mt-studenty.mt.ic.ac.uk:/opt/share/quantum-espresso /opt/share\nsudo mkdir /opt/Courses\nsudo rsync -auvz USER@mt-studenty.mt.ic.ac.uk:/opt/Courses/MSE404 /opt/Courses\n</code></pre> <p>Then you should have everything necessary in place. I would suggest re-running the last command at the beginning of each lab session to ensure you have the latest version of the lab documents.</p>"},{"location":"labs/extras/misc/vmsetup/readme/#if-you-do-not-have-access-to-the-server","title":"If you do not have access to the server","text":"<p>There are two directories present on the server that are referred to at various points in the lab documentation:</p> <ol> <li><code>/opt/share/quantum-espresso</code> - We have placed the various documentation    files (txt, html and pdf) that are provided with the quantum-espresso    source package in a directory here. It can be quite useful to refer to the    text files from the command line. However the same information can all be    found in the documentation    section of the    quantum espresso website. In particular the page with links to the input    data    description.</li> <li><code>/opt/Courses/MSE404</code> - this lets students copy a directory for the lab    containing the instructions and example files at the beginning of each lab    session. You could clone the git repository    https://gitlab.com/eamonnmurray/MaterialsModelling.git    whereever you like and use this instead. If you are a student taking the    course, I suggest pulling the repo at the beginning of each session as we    make changes as the course proceeds each year.</li> </ol> <p>For example, you could clone the repository to the same directory as on   the server:</p> <pre><code>sudo mkdir -p /opt/Courses\nsudo git clone https://gitlab.com/eamonnmurray/MaterialsModelling.git /opt/Courses/MSE404\n</code></pre> <p>This will create the folder <code>/opt/Courses/MSE404</code> with all the material   for all the labs. To update this ahead of a lab session you can do</p> <pre><code>cd /opt/Courses/MSE404\nsudo git pull\n</code></pre>"},{"location":"labs/lab01/readme/","title":"Getting Started in Linux","text":""},{"location":"labs/lab01/readme/#connecting-to-the-linux-server","title":"Connecting to the Linux server","text":"<p>Most materials modelling research of the type you will be learning about in this course is done through the Linux Operating System. For example, all the major High Performance Computing (HPC) resources you may eventually use, such as ARCHER2 which is a national HPC facility and CX1 which is the Imperial HPC system, run Linux.</p> <p>In this course, you will also be using a Linux server to run your calculations. You can remotely open a desktop session on the server we will be using with <code>x2go</code> which can be run from the Imperial Software Hub if you're using a lab workstation. If you'd prefer to use your own laptop to connect, you'll need to download and install the x2go client that's freely available via their website.</p> <p>If there is not already a session named \"mt-studenty\" or \"mt-studentx\" visible  in the right-hand list on x2go when you start it up, you will need to create it.</p> <ul> <li>The shortcut to create a new session is \"Ctrl+n\".</li> <li>In this menu, you should name the session \"mt-studenty\" or \"mt-studentx\".</li> <li>Set the Host as \"mt-studenty.mt.ic.ac.uk\" or \"mt-studentx.mt.ic.ac.uk\".</li> <li>Select \"XFCE\" as the session type in the bottom drop down menu.</li> <li>An image of this is given below:</li> </ul> <ul> <li>Once you have set this, click OK.</li> <li>Then select the session from the right-hand menu (e.g. click on the   picture).</li> <li>Enter your Imperial username and password to login.<ul> <li>The username is case sensitive and should be in lowercase letters.</li> </ul> </li> <li>Note: while I try to ensure students registered for the course have   access before the first class, I may not have the most up-to-date   information. If it doesn't accept your login details please let me know   and I can give you access.</li> <li>If it is your first time connecting it may ask you whether you want to   accept the host key (or something to that effect), to which you should click   \"yes\".</li> <li>If using a college workstation you may also get some pop up messages   about pulseaudio which you're free to ignore.</li> <li>It will take a minute or so for the session to fully start up so by patient.</li> <li>When logging in for the first time, once the desktop loads it will ask if   you want to accept the default menu configuration. You should accept the   default here. If you do not, you'll have no desktop menus. You can still   access everything by right clicking on the desktop. The desktop menus are   all customizable and you can always  change them later however you'd like,   but the default is the best place to start. If you make any customizations,   they'll be remembered when you next log in.</li> <li>I'd suggest also turning the sound volume on your pc down as command line   work can produce a lot of beeps which may become annoying.</li> </ul> <p>Once you've loaded into the desktop session, feel free to take a look around the menus and settings that are there. This is the XFCE desktop manager, and while it is basic, it is quite light on resources (important as you are all in fact using a single powerful workstation simultaneously), and very customizable.</p>"},{"location":"labs/lab01/readme/#using-the-command-line","title":"Using the command line","text":"<p>For the majority of first principles codes calculations are launched from the command line, so it's important to have some familiarity with it. Often, when running calculations on a HPC system, the command line will be the only way to access the system. While you'll be able to use a file manager on the desktop to access files, I encourage you to use the command line instead even if it takes you a little longer initially.</p> <p>The terminal application brings you to the command line and allows you to type in various commands and instructions directly. Open the terminal application from the menu. You can customize the appearance to your preference by changing the text size, font and colour scheme.</p> <p>You can launch a program from the terminal by typing its name. For example typing <code>gedit</code> will launch the gedit text editor by default. Note if you do this now, you won't be able to use the same terminal until gedit is closed. A way around this is discussed later in the lab.</p>"},{"location":"labs/lab01/readme/#files-and-directories","title":"Files and Directories","text":"<p>Once you have opened the terminal, the first thing you need to be able to do is navigate the file structure.</p>"},{"location":"labs/lab01/readme/#ls","title":"ls","text":"<p><code>ls</code> is used to list the contents of a directory. Please note the first character of this command is the lowercase <code>L</code> rather than the digit <code>1</code>. Try typing it now. By default you should start off in your home directory when you open a terminal, so you should see several automatically generated directories. Note <code>ls</code> has been set to use colour highlighting for you by default, so different types of files are shown in different colours.</p> <p>You can list the contents of any directory by name. For example:</p> <ul> <li><code>ls /opt/share/</code> will list the contents of that directory. Here we have   provided the full (absolute) path, since we started with <code>/</code>.<ul> <li>The filesystem hierarchy always has <code>/</code> as the very top level directory   for a linux system.</li> <li>If we specify a path to a directory, beginning with   <code>/</code> it means we are giving its absolute path from the top level   directory down to its location.</li> <li>Your home directory is <code>/home/username/</code> where <code>username</code> is your   college id. <code>~</code> is a shortened way to write this: <code>~</code> also refers to   your home directory.</li> </ul> </li> <li><code>ls Documents</code> will list the contents of the <code>Documents</code> directory below   the current directory if it exists. This is the same as typing   <code>ls ./Documents</code> as will be discussed later. Note this directory is empty   to begin with so you won't see any output from this command.<ul> <li>Here we specify a path without a leading <code>/</code>. It means we are referring   to a file or directory relative to your current location.</li> </ul> </li> </ul>"},{"location":"labs/lab01/readme/#useful-options","title":"Useful Options","text":"<ul> <li><code>ls -lh</code>. The <code>-l</code> option requests a long listing format, giving extra   details about each file and folder, such as permissions, owner, size, and   modification date. The <code>-h</code> requests sizes in a human-readable format,   otherwise sizes are listed in bytes i.e. with this option <code>ls</code> would list   \"4.0K\" instead of \"4096\".</li> <li><code>ls -a</code>. This tells <code>ls</code> to list all files, i.e. to not to ignore files   starting with \".\" which are typically hidden by <code>ls</code> and often used to store   various user configuration files. Try typing this now, and you'll see many   more files and folders than previously.</li> </ul>"},{"location":"labs/lab01/readme/#pwd","title":"pwd","text":"<p><code>pwd</code> will output the name of the present working directory. Try using it now. It should respond with something like <code>/home/username</code>.</p>"},{"location":"labs/lab01/readme/#cd","title":"cd","text":"<p><code>cd</code> is used to change directory. You can specify either the full path, or a directory relative to your current directory.</p> <ul> <li><code>cd Documents</code> to move to the <code>/home/username/Documents</code> directory assuming   we are in <code>/home/username</code>.</li> <li><code>cd /home/username/Desktop</code> to move to the users <code>Desktop</code> directory   regardless of where we start from.</li> <li><code>cd ..</code> to move up one directory.</li> <li><code>cd .</code> to move to the present directory (i.e. do nothing).</li> <li><code>cd</code> and <code>cd ~</code> will both move to your home directory.</li> </ul>"},{"location":"labs/lab01/readme/#task","title":"Task","text":"<p>Now that you know these few commands, let's take a look at some important locations on the system for this course:</p> <ul> <li>The various files associated with the labs for this course are all available   in <code>/opt/Courses/MSE404</code>.</li> <li>The documentation files for the version of Quantum Espresso we will be using   are all collected in <code>/opt/share/quantum-espresso/doc-6.3</code>.</li> <li>Try changing to each of these directories now and taking a look at files   that are contained in each of them.</li> </ul>"},{"location":"labs/lab01/readme/#mkdir","title":"mkdir","text":"<p><code>mkdir</code> is used to create new directories. For example <code>mkdir carbon</code> will create a new directory called <code>carbon</code>.</p>"},{"location":"labs/lab01/readme/#useful-options_1","title":"Useful Options","text":"<ul> <li><code>mkdir -p</code> can be used to make parent directories as needed. For example,   <code>mkdir -p carbon/lda/dos</code> if <code>carbon</code> already exists will create <code>lda</code> as a   subdirectory of it, and <code>dos</code> as a subdirectory of <code>lda</code>.</li> </ul>"},{"location":"labs/lab01/readme/#rm","title":"rm","text":"<p><code>rm</code> is used to delete files. For example, if we create a text file with the text editor <code>gedit</code> called <code>tmp</code>, then we can delete it with <code>rm tmp</code> in the directory that contains it.</p>"},{"location":"labs/lab01/readme/#useful-options_2","title":"Useful Options","text":"<ul> <li><code>rm -r</code> will recursively delete a directory and any files contained in it.</li> <li><code>rm -f</code> can be used to force deletion without prompting. Combine with the   previous option with caution. There is no recycle bin when using <code>rm</code>.   When you use it to delete a file it is gone, unless you have a backup.   (On mt-studenty and mt-studentx there are daily snapshots you can recover    deleted files from in ~/.snapshots)</li> </ul>"},{"location":"labs/lab01/readme/#rmdir","title":"rmdir","text":"<p><code>rmdir</code> is used to delete directories. Note this will give an error if the directory you try to delete is not empty.</p>"},{"location":"labs/lab01/readme/#cp","title":"cp","text":"<p><code>cp</code> is used to copy files. For example, <code>cp sourcefile newfile</code> would copy the file <code>sourcefile</code> to <code>newfile</code>.</p>"},{"location":"labs/lab01/readme/#useful-options_3","title":"Useful Options","text":"<ul> <li><code>cp -r</code> will recursively copy a directory and any files contained in it.</li> </ul>"},{"location":"labs/lab01/readme/#mv","title":"mv","text":"<p><code>mv</code> is used to move or rename files. For example, <code>mv oldfilename newfilename</code> would rename a file from \"oldfilename\" to \"newfilename\", while <code>mv filename ../</code> would move \"filename\" to the parent directory.</p>"},{"location":"labs/lab01/readme/#ln","title":"ln","text":"<p><code>ln</code> is used to create links. These are somewhat similar to shortcuts in windows except that they operate at the filesystem level. A link to a file can be used in the same way as the file itself. They are useful for many reasons: - Convenience: you may want to frequently use a particular directory, but it   has quite a long path. You can create a link to it in your home directory   and use the link in exactly the same manner as the original path. - Saving space: For example, when working with a code that expects a certain   file as input in the current directory. If the file is very large you might   want to avoid making copies of it, so you can instead make a link to the   file. - If a parameter file is used in several places, you can use links so that   when you update one file, they are all updated, instead of having to update   several copies manually.</p> <p>Note, while the other commands we've looked at so far can all be done through the file manager rather than the command line, link creation is less well supported or at least less obvious in most file manager software.</p> <p><code>ln</code> can create two types of links: hard links are created by default, and symbolic links are created when the <code>-s</code> option is specified. Symbolic links contain text which points to a particular file, while hard links point to the same data on the disk as the original file. It's generally simplest to stick to symbolic links, especially starting out. An example of how links are used is as follows:</p> <ol> <li><code>mkdir tmpdir1; mkdir tmpdir2; touch tmpdir1/tmpfile1</code> This will create two    directories and a file in one of them. Note semi-colons can be used to    separate commands on the same line. And we have also used the <code>touch</code>    command which offers a quick way to create an empty file.</li> <li><code>cd tmpdir2</code> Move to the tmpdir2 directory.</li> <li><code>ln -s ../tmpdir1/tmpfile1 tmpfile2</code> This will create a symbolic link to    the file.</li> <li><code>ln -s ../tmpdir1 .</code> will create a link to the <code>tmpdir1</code> directory in    <code>tmpdir2</code>.</li> <li>Typing <code>ls</code> in the <code>tmpdir2</code> directory will show the files <code>tmpfile2</code> and    <code>tmpdir1</code>. If your colour highlighting is working, you should see these as    different colours to usual files (probably light blue). To see where the    links point you can use <code>ls -l</code>.</li> </ol> <p><code>cp -s</code> can also be used to create symbolic links (with <code>cp -l</code> creating hard links), and can be a little easier to use, particularly for linking a set of files. - <code>cp -s ../results/*dat .</code> would create symbolic links from all the <code>.dat</code>   files in the results directory to the current directory.</p> <p>If you create a link to a directory, one thing that may not be immediately obvious is how to delete it. Say your link is called <code>tmpdir</code>. If you try <code>rm tmpdir/</code> you'll get the error <code>rm: cannot remove 'tmpdir': Is a directory</code>. Then if you try <code>rmdir tmpdir/</code> you'll get the error <code>rmdir: failed to remove 'tmpdir/': Not a directory</code>. What you need to do is use <code>rm</code> but ensure you don't have a trailing slash following the link name: <code>rm tmpdir</code>. NB if you use <code>rm -r tmpdir/</code>, this will delete the contents of the directory you have linked to which is likely not what you want to do, so be careful.</p>"},{"location":"labs/lab01/readme/#useful-options_4","title":"Useful Options","text":"<ul> <li><code>ln -sf</code>: the additional <code>-f</code> option forces the link to overwrite any   pre-existing files or links.<ul> <li>For example, if we had incorrectly done <code>ln -s ../tmpdir1/tmpdir1 .</code> in   the above example, the link would have been created, but wouldn't point   to any valid file. <code>ls</code> will usually show these invalid links as red. We   could then do <code>ln -sf ../tmpdir1 .</code> to overwrite the <code>tmpdir1</code> link with   the correct path, rather than deleting incorrect link and repeating the   <code>ln</code> command.</li> </ul> </li> </ul> <p>Note If you create a link correctly and have colour highlighting in the terminal application you are using, symbolic links that work will be blue. If they are red it means they don't point to a valid file or directory. You can use <code>ls -l</code> to see where a symbolic link points. If you've made a mistake you'll need to either delete the incorrect link, or use the <code>-f</code> flag as described above to overwrite it.</p>"},{"location":"labs/lab01/readme/#task_1","title":"Task","text":"<p>Now that you know how to copy files and make directories, let's set up some folders for the labs in the course. While it's of course possible to do this through the file manager, please use the commands we've gone through so far to do the following:</p> <ul> <li>In your home directory make the directory <code>MSE404</code>.</li> <li>Copy the directory with the input files for this course   <code>/opt/Courses/MSE404/lab01</code> to the directory you just created <code>~/MSE404</code>.   Remember you need to pass an additional flag to <code>cp</code> to copy a directory.</li> <li>List the contents of directory <code>~/MSE404/lab01/methane</code> with <code>ls -l</code><ul> <li>You'll see there are three files in the directory you copied.</li> <li><code>CH4.in</code> - an input file for the DFT code you'll be using.</li> <li><code>C.pz-vbc.UPF</code> - a pseudopotential file for carbon, which tells the DFT code   what approximation to use in your calculation.</li> <li><code>H.pz-vbc.UPF</code> - a pseudopotential file for hydrogen, which tells the DFT code   what approximation to use in your calculation.</li> <li>You'll learn more about these types of files in later classes.</li> <li>If you've followed the steps as given here, and have colour highlighting   in the terminal application you're using, you'll see the pseudopotential files are   highlighted in red when you did <code>ls -l</code>. This is because they are links   and currently don't point to valid files. It's looking for files at   <code>../../pseudo/C.pz-vbc.UPF</code> and <code>../../pseudo/H.pz-vbc.UPF</code>    where <code>../..</code> means go up two directories   from the current directory. In other words this is looking for the files   at <code>~/MSE404/pseudo/C.pz-vbc.UPF</code> and <code>~/MSE404/pseudo/H.pz-vbc.UPF</code>.   You'll correct this in the next step.</li> </ul> </li> <li>Go to the <code>~/MSE404</code> directory and make a copy there of the directory   holding various pseudopotentials used in the course:   <code>/opt/Courses/MSE404/pseudo</code>. You should now see that the file in   <code>~/MSE404/lab01/methane</code> is blue when you do <code>ls</code> in this directory   indicating it can now find a file in the location specified by the link.</li> <li>Within your <code>MSE404</code> directory also create a symbolic link to the Quantum   Espresso documentation folder <code>/opt/share/quantum-espresso/doc-6.3</code> called   <code>qe-doc</code>.</li> </ul>"},{"location":"labs/lab01/readme/#tab-completion","title":"Tab completion","text":"<p>A useful feature which has long been available in the Linux terminal is tab completion. This is also referred to as command-line completion. These days this is available in both Mac and Windows systems also.</p> <p>Try typing <code>ged</code> in a terminal and hitting <code>tab</code>. The full name of the program <code>gedit</code> should automatically fill in. If more than one match is possible, pressing <code>tab</code> twice will bring up a list of possible matches. Try typing <code>ge</code> and pressing tab twice to see this.</p> <p>This can also be used to complete file and directory names. From your home directory, try typing <code>cd De</code> and pressing tab. It should automatically fill in the full command to be <code>cd Desktop/</code>.</p>"},{"location":"labs/lab01/readme/#reading-a-file","title":"Reading a file","text":"<p>There are several built-in programs that will allow you to examine a text file in the terminal.</p>"},{"location":"labs/lab01/readme/#cat","title":"cat","text":"<p><code>cat</code> is the simplest command to check the output of a file. - <code>cat filename</code> will output the contents of <code>filename</code> to the terminal. For a   large file you may need to scroll back up in the terminal (e.g.   <code>shift+PdgUp</code>).</p>"},{"location":"labs/lab01/readme/#more","title":"more","text":"<p><code>more</code> works in a somewhat similar way to <code>cat</code>, except for files bigger than the terminal window, it allows you to look through a page (screen) full of data at a time.</p> <ul> <li><code>more filename</code> to start paging through a file.</li> <li>To move to the next page press <code>space</code> or <code>z</code>.</li> <li>To move down one line of text press <code>enter</code>.</li> <li>To quit before reaching the end of the file press <code>q</code>.</li> </ul>"},{"location":"labs/lab01/readme/#less","title":"less","text":"<p><code>less</code> is more advanced version of <code>more</code> with many more features. This doesn't output file contents to the terminal however, so once you exit <code>less</code> your terminal will be as it was before the file was opened.</p> <ul> <li><code>less filename</code> to open a file.</li> <li>move down one line: <code>down-arrow</code>, <code>enter</code>, <code>j</code>, or <code>e</code>.</li> <li>move up one line: <code>up-arrow</code>, <code>y</code>, or <code>k</code>.</li> <li>move down one page: <code>page-down</code>, <code>space</code>, or <code>f</code>.</li> <li>move up one page: <code>page-up</code>, <code>w</code>, or <code>b</code>.</li> <li>search for a string of text: <code>/</code>, type in the search text and press enter.</li> <li>A useful feature when trying to check a file that is currently being written   to is to press <code>F</code>. This is similar to <code>tail -F</code>. It will scroll forward and   keep trying to read when the end of the file is reached. To exit this mode   press <code>ctrl+c</code>.</li> <li>quit: <code>q</code>.</li> </ul>"},{"location":"labs/lab01/readme/#task_2","title":"Task","text":"<p>Let's try taking a look at one of the quantum-espresso documentation files at <code>~/MSE404/qe-doc/INPUT_PW.txt</code> (since you linked the folder in the previous set of tasks).</p> <ul> <li>Try looking at this file with <code>cat</code>. You'll see the entire file is dumped   straight to your terminal. If you want to scroll up and down from the   keyboard you can do this with <code>shift+PdgUp</code> and <code>shift+PdgDwn</code>.</li> <li>Now try looking at the same file with <code>less</code>. Now you can scroll up and down   with the arrow keys or with the <code>k</code> and <code>j</code> keys.</li> <li>Within less, search for the text <code>disk_io</code>.</li> <li>Take a look at the file <code>~/MSE404/lab01/methane/CH4.in</code> in <code>less</code>. This is   a basic Quantum Espresso input file. You'll be learning more about this in   the next lab.</li> </ul>"},{"location":"labs/lab01/readme/#other-useful-command-line-features","title":"Other Useful Command Line Features","text":"<p>While at first, the command line can seem quite basic. There are many built-in features that allow you to work extremely efficiently after a little practice.</p>"},{"location":"labs/lab01/readme/#the-manual-and-man-command","title":"The Manual and man command","text":"<p>Linux systems provide an interface to a built-in reference manual through the <code>man</code> command. This is very useful as a quick way to check the syntax used by a command, and what options it might take.</p> <ul> <li>Type <code>man ls</code> to check the manual page for the ls command.</li> <li>Type <code>man man</code> to check the manual page for the man command.</li> <li>Type <code>man intro</code> to get an introduction to user commands.</li> </ul> <p>When reading the manual data, by default it should use the <code>less</code> pager, so you can use all the commands for <code>less</code> listed above to navigate and search through the manual.</p>"},{"location":"labs/lab01/readme/#wildcards","title":"Wildcards","text":"<p>In Linux many commands will accept wild cards as a way to perform their action on a set of files.</p> <ul> <li><code>*</code> is used to represent zero or more characters. The <code>*</code> wildcard is very   commonly used and worth remembering.<ul> <li><code>ls *.pdf</code> would list all the files ending in <code>.pdf</code> in the current   directory.</li> <li><code>rm *.o</code> would remove all files ending in <code>.o</code> in the current directory.</li> </ul> </li> <li><code>?</code> is used to represent any single character.<ul> <li><code>cp ../example?.cpp .</code> would copy all files with names such as   <code>example1.cpp</code>, <code>example2.cpp</code>, <code>examplea.cpp</code> from the parent to the   current directory.</li> </ul> </li> <li><code>[]</code> specifies a range.<ul> <li><code>ls example_0[2,3,5]</code> would list files with the name <code>example_02</code>,   <code>example_03</code> and <code>example_05</code>.</li> <li><code>ls example_0[3-5]</code> would list files with the name <code>example_03</code>,   <code>example_04</code> and <code>example_05</code>.</li> </ul> </li> </ul> <p>For more information on this see <code>man 7 glob</code>.</p>"},{"location":"labs/lab01/readme/#io-redirection","title":"IO Redirection","text":"<p>IO redirection allows you to easily send the output of a command to a file, use a file as input for a command, or use the output of one command as input to another command. The most frequently used features are as follows:</p> <ul> <li><code>&gt;</code> is used to redirect the output from a command into a file.<ul> <li><code>ls &gt; dirlist.txt</code> will save the result of the <code>ls</code> command in a file   called <code>dirlist.txt</code>. Take care: if <code>dirlist.txt</code> already exists it   will overwrite the previous contents.</li> </ul> </li> <li><code>&amp;&gt;</code> is used to redirect both the standard output and standard error from a   command to the same file.</li> <li><code>&gt;&gt;</code> is used to redirect the output from a command to a file, but will append   the output to the end of the file if the file already exists.<ul> <li>If you run <code>ls &gt;&gt; dirlist.txt</code> you will see the ls output repeated   several times in the file <code>dirlist.txt</code>.</li> </ul> </li> <li><code>&lt;</code> is used to redirect a file to the input of a command.<ul> <li><code>less &lt; dirlist.txt</code> will work as <code>less</code> is happy to read either from   stdin or a file.</li> </ul> </li> <li><code>|</code> is used to redirect the output of a command to the input of another   command.<ul> <li><code>ls | less</code> will take the output of the <code>ls</code> command and display it   directly in <code>less</code> (this is why it's useful for <code>less</code> to be able to read   from stdin).</li> </ul> </li> <li><code>tee</code> allows you to split a stream so that the output goes both to stdout and   to a file.<ul> <li><code>ls -l | tee dirfiles</code> will output the result of <code>ls -l</code> to the terminal   and also save it in the file <code>dirfiles</code>.</li> </ul> </li> </ul>"},{"location":"labs/lab01/readme/#history","title":"History","text":"<p>By default the terminal keeps a history of previously entered commands. You can scroll back through previously entered commands using the <code>up-arrow</code> and <code>down-arrow</code> keys.</p> <p>The <code>history</code> command will output a list of all the previously entered commands following a history index number. By default the list is usually limited to 1000 commands, with the oldest being removed as new commands are entered. You can look at the full list with <code>history | less</code>.</p> <ul> <li><code>!!</code> will repeat the most recent command.</li> <li><code>!n</code> will repeat the command indexed by <code>n</code> in the history list. For example   <code>!100</code> would repeat the command at history index 100.</li> <li><code>!string</code> will repeat the most recent command in the history starting with   \"string\".</li> </ul> <p>For more details see <code>man history</code>.</p> <p>The linux shell also gives a built in way to search through previously entered commands. You can press <code>ctrl+r</code> to bring up the reverse-history-search and type some text from the command you want to re-enter. You can keep hitting <code>ctrl+r</code> to search back through commands containing that text. If you accidentally go past the entry you want, <code>ctrl+s</code> will go forward through your history.</p> <p>An additional useful shortcut is 'alt+.' which will enter the most recent argument you used, and repeated presses will cycle back through arguments.</p>"},{"location":"labs/lab01/readme/#job-control","title":"Job Control","text":"<p>Linux allows jobs to run both in the foreground and background of a terminal session. If we launch a program from the terminal by typing e.g. <code>gedit</code> and pressing enter (<code>gedit</code> is a text editor), then we can't can't do anything else in the terminal until <code>gedit</code> is closed. <code>gedit</code> is said to be running in the foreground in this case.</p> <p>With <code>gedit</code> running in the foreground, we can move it to the background as follows.</p> <ol> <li>In the terminal where it is running, press <code>ctrl+z</code>. This stops the job. A    message will appear in the terminal like    <code>[1]+  Stopped gedit</code>. If you try to type, or click any menu buttons, on    <code>gedit</code> it won't respond.</li> <li> <p>Type <code>bg</code> in the terminal. This moves the most recent stopped job to the    background, i.e. <code>gedit</code> in this example. Now you'll be able to use both    <code>gedit</code> and the terminal as normal.</p> </li> <li> <p>To move a job that's running in the background, back to the foreground you   can use the <code>fg</code> command.</p> </li> <li>To start a job in the background you can append <code>&amp;</code> to the command when you   enter it in the terminal. For example <code>gedit &amp;</code> will launch <code>gedit</code> in the   background directly.</li> </ol>"},{"location":"labs/lab01/readme/#environment-variables","title":"Environment Variables","text":"<p>There are a couple of environment variables that are important for running commands via the command line.</p> <ul> <li><code>$PATH</code> - this is a colon-separated list of directories that are searched   for executables to run when you type in a command without specifying any   path.<ul> <li>If you type <code>echo $PATH</code> you can see what this is.</li> <li>For example, when you type <code>gedit</code>, it searches each directory in turn   for an executable named <code>gedit</code>, and runs the first one it finds.</li> <li>You can use the <code>which</code> command to see where it would find an   executable.</li> <li>For example <code>which gedit</code> returns <code>/usr/bin/gedit</code> on our system.</li> <li>Note you can run a particular executable by specifying it's path and not   relying on <code>$PATH</code>. So if <code>$PATH</code> was unset, we could type   <code>/usr/bin/gedit</code>, or we could do <code>cd /usr/bin</code>, <code>./gedit</code>.</li> </ul> </li> <li><code>$LD_LIBRARY_PATH</code> - this is a colon-separated list of additional   directories to search for libraries used by applications.<ul> <li>Libraries are pieces of code that are common to many applications, so   are shared and installed separately. And when the application is run, it   tries to find this library.</li> <li>Generally, most default OS software will work fine without this set, but   if you're using some custom mathematical libraries or compilers this may   be needed.</li> </ul> </li> </ul>"},{"location":"labs/lab01/readme/#environment-modules-lmod","title":"Environment Modules: Lmod","text":"<p>Environment modules simplify the whole process of changing environment variables to get some custom software package working. When a module is loaded it sets whatever environment variables are required automatically. This lets many different and possibly conflicting software versions be installed on the same system. Environment modules are almost always used on HPC systems to make various versions of common version of computational software packages available. The version installed on mt-studenty/mt-studentx is called Lmod.</p> <ul> <li>The main command is <code>module</code>.</li> <li>For help type <code>module help</code> (the same text is output if you just <code>module</code>).</li> <li>To see what modules are currently available type <code>module avail</code>. (some   groups of modules which require a compiler module to be loaded will not be   visible).</li> <li>To load the module making software compiled using the gcc compilers   available type <code>module load gcc</code>. This makes some additional modules   available.</li> <li>To see a complete list of all modules type <code>module spider</code>.</li> <li>The particular module implementation we use allows us to easily switch   between versions of codes compiled with different compilers.</li> <li>For example to load the Quantum Espresso module, you'll first need to   have the \"gcc\" and \"mkl\" modules loaded. You can load everything in a   single command though provided the order is correct:</li> </ul> <p><pre><code>module load gcc mkl espresso\n</code></pre> - Throughout the course, when running on the undergrad server you'll need to   remember to load the modules above before you'll be able to use the codes   in the Quantum Espresso package. - If you want to have the modules necessary loaded automatically whenever you   log in to the server, you can add the above module load command to the   end of the file <code>~/.bashrc</code>. This file is run whenever your start a shell   and can be used to customize your environment.</p>"},{"location":"labs/lab01/readme/#task_3","title":"Task","text":"<p>Now you know enough to run your first DFT calculation.</p> <ul> <li>First we need to load the Quantum Espresso module. An optimized compilation   of this is available on the system compiled with the GCC compilers and   Intel Math Kernel Libraries. Type the following in your terminal to load   everything you need in one go <code>module load gcc mkl espresso</code> to load   everything you need.</li> <li>Now you'll be able to use the various Quantum Espresso package executables   directly. Go to the methane folder you copied earlier   (<code>~/MSE404/lab01/methane</code>) and look at what files are in that directory.</li> <li>The input file there is for the <code>pw.x</code> code. You can pass this file to   <code>pw.x</code> with input redirection and save the output to a file with output   redirection (otherwise the output will just be in the terminal). To do this   type <code>pw.x &lt; CH4.in &gt; CH4.out</code>.</li> <li>See what files are present in the directory now. As well as the output file   we saved, some others were generated.</li> <li>Take a look through the output file using <code>less</code>. We'll discuss the   contents of this in next week's lab, but for now skip to the section   immediately following the line that reads   <code>End of self-consistent calculation</code>:<ul> <li>This lists the calculated eigenvalues.</li> <li>We have four doubly-occupied bands in our calculation, so you'll see   four numbers.</li> <li>Following this, you can see in the output, the value of the highest occupied   energy level in eV, and the total energy in Rydberg.</li> </ul> </li> <li>Congratulate yourself on running your first DFT calculation.</li> </ul> <p>There are a lot of commands to remember from this week's lab. You can always refer back to this week, but to make things easier in future weeks you might find a cheatsheet useful. If you don't want to make your own, a quick Google search of <code>Linux cheat sheet</code> brings up a number of options.</p> <p>If you're interested in seeing some more command line tools, some of these are listed in linuxcommands. If you have time, I encourage you to at least skim through them, as it's very useful to know what kinds of things are possible. We'll refer back to some of these commands throughout the course.</p> <p>Once you're finished with everything, be sure to log out of the remote desktop session. You can see this option if you click on your name on the top right.</p>"},{"location":"labs/lab01/readme/#summary","title":"Summary","text":"<p>To run the DFT example in this lab you will need to do the following:</p> <ul> <li>Make a directory that will hold the material for the MSE404 labs:   <code>mkdir ~/MSE404</code>.</li> <li>Copy the directory with the inputs for this lab to this directory:   <code>cp -r /opt/Courses/MSE404/lab01 ~/MSE404</code>.</li> <li>Copy the directory with the various pseudopotential files to this directory   also: <code>cp -r /opt/Courses/MSE404/pseudo ~/MSE404</code>.</li> <li>Make a link to the Quantum Espresso documentation directory in your home directory:   <code>cd ~/MSE404; ln -s /opt/share/quantum-espresso/doc-6.3 ./qe-doc</code>.</li> <li>Load the modules needed to run Quantum Espresso:   <code>module load gcc mkl espresso</code>.</li> <li>Go to the directory with the input files you copied and use these with   <code>pw.x</code> saving the output in a file:   <code>cd ~/MSE404/lab01/methane; pw.x &lt; CH4.in &gt; CH4.out</code>.</li> <li>Take a look through the output file:   <code>less CH4.out</code>.</li> <li>Logout of the remote server once you're done.</li> </ul>"},{"location":"labs/lab02/readme/","title":"Quantum Espresso Input and Output for Molecules","text":""},{"location":"labs/lab02/readme/#quantum-espresso","title":"Quantum Espresso","text":"<p>Quantum Espresso is a freely available package of open-source codes for electronic-structure calculations and materials modelling at the nanoscale. It is based on density-functional theory, plane waves, and pseudopotentials, which you will be learning about in the theoretical part of the course.</p> <p>Quantum Espresso is used via the command line. There is no graphical interface by default. This is typical of most electronic structure codes, where you are often interacting with a remote HPC system solely via ssh, and submitting calculations and text-file scripts to a queueing system which takes your calculation and executes it on some set of compute server nodes when they become available.</p> <p>To run a calculation you first need to make an input file, describing the various calculation parameters along with giving the location of any other input files that will be used. Then you run the code giving it your input file (redirected from stdin in the case of Quantum Espresso - see lab 1), and it will create one or more files with the result of your calculation and potentially intermediate data also.</p> <p>First you'll need to copy the material for this Lab to your home directory. You should already have a directory named <code>MSE404</code> in your home directory; you can confirm this by going to your home directory and checking the contents with the following two commands:</p> <pre><code>cd ~\nls\n</code></pre> <p>If you don't see an <code>MSE404</code> folder listed, you can create it with</p> <pre><code>mkdir MSE404\n</code></pre> <p>The above command requests the creation of a directory named <code>MSE404</code> within whatever directory you are currently. If you weren't in your home directory you could still create a directory there, by giving the absolute path: <code>mkdir ~/MSE404</code>. Once you've confirmed you have the directory as expected, you can make a copy of the lab material there so that you can run the calculations for this lab, with <code>cp -r /opt/Courses/MSE404/lab02 ~/MSE404</code>.</p> <p>A set of basic input files for a variety of systems have been set up in the different directories here. In the material that follows you'll need to run the calculations in your own copy of this directory. You'll get an error if you try to run calculations anywhere under the <code>/opt</code> directory as you don't have the permissions needed to create files here.</p> <p>You should also ensure you have a copy of the directory with the pseudopotentials used for the labs:</p> <pre><code>cd ~/MSE404\ncp -r /opt/Courses/MSE404/pseudo .\n</code></pre>"},{"location":"labs/lab02/readme/#a-basic-input-file","title":"A basic input file","text":"<p>A simple example that will use the <code>pw.x</code> code from Quantum Espresso to calculate the total energy of methane is given in the directory <code>01_methane</code>. This is the same calculation you ran last week. Quantum Espresso uses periodic boundary conditions, so for molecules we just put the entire system in a large box, that we hope (we check) is big enough that periodic images don't interact, or interact weakly compared to the other interactions we're interested in.</p> <p>Let's first open the input file <code>CH4.in</code> and read through it. In this case we are relying on many default values that would normally be specified, but let's focus on the most important things to begin. There is an annotated version of this file called <code>CH4_detailed.in</code> which will let us go through the input in more detail. Take a look at this now.</p> <p>Sometimes we want to find out more information about a specific variable, for example <code>ibrav</code>. Take a look at the <code>pw.x</code> documentation file for more details on this variable: <code>less ~/MSE404/qe-doc/INPUT_PW.txt</code>. You should have made a link to the documentation across last week, but in case this gives you an error, then you can link using <code>ln -s /opt/share/quantum-espresso/doc-6.3 ~/MSE404/qe-doc</code>. You can search the documentation for <code>ibrav</code> by typing <code>/ibrav</code> and pressing enter. You can press <code>n</code> to go to the next match if you don't go straight to the main entry. (The input description is also viewable online.)</p>"},{"location":"labs/lab02/readme/#running-the-calculation","title":"Running the calculation","text":"<p>The Quantum Espresso package has been compiled as a module on the mt-student server. As discussed in the previous lab, modules are often used on HPC systems to make different versions of various packages as compiled with different compilers available to users. To add Quantum Espresso to your environment, along with its dependencies type the following in a terminal:</p> <pre><code>module load gcc mkl espresso\n</code></pre> <p>Now to run the code: make sure you are in the <code>01_methane</code> directory then do:</p> <pre><code>pw.x &lt; CH4.in\n</code></pre> <p>Here we redirected our input file to the stdin of <code>pw.x</code>, as described in the IO Redirection section of lab 1. (We could also have used the <code>-i</code> flag to specify an input file as <code>pw.x -i CH4.in</code>.) You'll see a lot of output has been generated in your terminal, but a simple calculation like this will finish quite quickly. It's better to explicitly save the output (and any error information) to a file. To do this, we can instead run the calculation a redirect the output to a file with</p> <pre><code>pw.x &lt; CH4.in &amp;&gt; CH4.out\n</code></pre>"},{"location":"labs/lab02/readme/#the-output-files","title":"The output files","text":"<p>Take a look in the directory with <code>ls</code>. You'll see some additional files have been generated. We have <code>pwscf.xml</code>, which has all the details of the system and results of the calculation in an xml format. If you skip to the end of this file (if you have opened it with <code>less</code>, then pressing <code>G</code> will go straight to the end, while <code>g</code> will go back to the start) you will see the eigenvalues and other details. Note, that while the band energies listed in the output file are in eV, those in the xml file are in Hartree units. And we have a folder called <code>pwscf.save</code>. This has some other files such as the charge density, another copy of the xml file we saw above, a copy of the pseudoptential that was used, and files with the calculated wavefunction stored in a binary format that can be used as input to other calculations.</p> <p>Now let's take a quick look through the output that we generated. (e.g. <code>less CH4.out</code>).</p> <ul> <li>First we have details of the code, version and date of the calculation.</li> <li>There's some info about the calculation details, including some numbers   where we had just accepted the defaults.</li> <li>Then we go into our self-consistent calculation, starting from randomized   atomic wavefunctions. At the end of each step it outputs the total energy.</li> <li>After seven steps we have converged to the default level, i.e.    <code>estimated scf accuracy</code> is below 1.0E-6.</li> <li>The eigenvalues are output in eV. Note although we have   8 electrons, we have treated them as 4 doubly occupied states, so only four   numbers are output.</li> <li>The total energy is listed, as well as its decomposition into several terms.</li> <li>And finally some timing information. If calculations are taking a long time   this can be helpful in seeing where it is spent.</li> </ul> <p>Note there are a number of equivalent ways of defining the unit cell vectors within Quantum Espresso. Instead of relying on choosing the correct <code>ibrav</code> value, we can set <code>ibrav = 0</code> and give the unit cell lattice vectors explicitly in a <code>CELL_PARAMETERS</code> section. This is shown in <code>01a_methane/CH4.in</code>.</p>"},{"location":"labs/lab02/readme/#task","title":"Task","text":"<ul> <li>Try running <code>pw.x</code> on the second methane input file and confirm you get the   same total energy as before.</li> </ul>"},{"location":"labs/lab02/readme/#methane-ethane-and-ethene","title":"Methane, ethane and ethene","text":"<p>Now we understand the basics of the Quantum Espresso input file, let's try some other molecules, in this case ethane and ethene. The only things that we need to change are the number of atoms and the atomic positions. The input  files are in C2H6.in and C2H4.in. If you want to see what we've changed in the ethane input file relative to the methane input file a useful tool is <code>diff</code>. If you're in the <code>lab02</code> directory you can type <code>diff 01_methane/CH4.in 02_ethane/C2H6.in</code>. You'll be able to see that we've only changed a few lines in our input file and everything else is the same.</p>"},{"location":"labs/lab02/readme/#task_1","title":"Task","text":"<ul> <li>Run <code>pw.x</code> for ethane and ethene and save the outputs.</li> <li>How do the eigenvalues compare between molecules?</li> </ul> <p>Note that, unlike for methane, we specified the atomic units in bohr for both  ethane and ethene. One common mistake is using the wrong units. What happens if you get the units wrong?</p>"},{"location":"labs/lab02/readme/#task_2","title":"Task","text":"<ul> <li>Change the units of the atomic positions for ethene and run   <code>pw.x</code> again. What happens?</li> </ul>"},{"location":"labs/lab02/readme/#c20-isomers","title":"C<sub>20</sub> isomers","text":"<p>While the total energy of a molecule isn't that useful by itself, the relative energies between, say, different isomers of a given molecule are much more useful. In general (ignoring e.g. temperature effects), a lower energy indicates a more stable isomer. As an example, let's consider three different isomers of C<sub>20</sub> - a bowl, ring and cage structure (see https://pubs.acs.org/doi/abs/10.1021/acs.jpca.5b10266).</p>"},{"location":"labs/lab02/readme/#task_3","title":"Task","text":"<ul> <li> <p>Run the inputs for the different isomers, found in   <code>C20_bowl.in</code>, <code>C20_ring.in</code>   and <code>C20_cage.in</code>. Which one has the lowest total energy?</p> </li> <li> <p>The three isomers are close in energy, so how can we tell if the difference is   significant? Let's try looking at an amorphous structure.</p> </li> <li> <p>Run the inputs for the amorphous structure, found in   <code>C20_amorphous.in</code>. How does the energy   compare to the previous isomers? Is it what you expected?</p> </li> <li> <p>Finally, let's see what happens if we try something less realistic. In    <code>C20_smile.in</code> there is an input file for a structure   which resembles a smiley face. Run this calculation and compare the energies.</p> </li> </ul> <p>It turns out that the relative energies of the ring, cage and bowl structure are very sensitive to the details of the approach used, as seen in this paper. For these systems, it is therefore hard to say with certainty which is the most stable isomer using DFT. However, by comparing with less realistic structures we can still see the difference in energy between structures which should be stable and those which should not.</p> <p>Finally, note that if you were to use a structure which more closely resembles a smiley face, Quantum Espresso is unable to reach convergence within 100 iterations, just like when you use the wrong units. So if you encounter convergence problems, the first thing to check should be whether or not your input structure is sensible.</p>"},{"location":"labs/lab02/readme/#visualizing-structures","title":"Visualizing Structures","text":"<p>There are many different tools that can be used to visualize atomic structures. <code>xcrysden</code> is installed as a module on the server you're using for this course, and conveniently can read Quantum Espresso input files. Try loading the module with <code>module load xcrysden</code>, running the command <code>xcrysden</code> and opening the input files for the various structures we've looked at in this lab. You can do this by selecting <code>Open PWscf</code> on the file menu. Note that since we are viewing a molecule, xcrysden will open a menu asking whether to reduce the dimensionality. Select <code>reduce dimension to 0D</code>.  There are many options to control how the structure looks, and you can grab and rotate the structure with your mouse.</p>"},{"location":"labs/lab02/readme/#task_4","title":"Task","text":"<ul> <li>See if you can figure out how to save an image of each C<sub>20</sub> isomer   as a png file.</li> </ul> <p>We can also use <code>xcrysden</code> to visualize other quantities, such as the charge density. If you've got time left in this lab, check out the additional material on <code>visualization</code>, which shows you how to visualize the charge density of methane.</p>"},{"location":"labs/lab02/readme/#summary","title":"Summary","text":"<ul> <li>In this lab we've looked at how to create an input file for some different   molecules:</li> <li>Methane, ethane and ethene.</li> <li>Different isomers of C<sub>20</sub>.</li> <li>We've also looked at how to visualize the structures.</li> <li>As an optional extra, try setting up inputs for some other molecules of your   choice.</li> </ul>"},{"location":"labs/lab02/readme/#extra-other-molecules","title":"Extra - Other molecules","text":"<p>In this course we give you the coordinates of the materials that you need to  simulate. But what if you want to try something different? For molecules, Avogadro is a useful for progam for visualizing and generating structures for a range of molecules. The online documentation will show you how to build different molecules. Once you are happy, you can  save the coordinates as a <code>.xyz</code> file, which will write the atomic positions in Angstrom. You can then insert these coordinates into a Quantum Espresso input file.</p>"},{"location":"labs/lab02/readme/#optional-task","title":"Optional Task","text":"<ul> <li>Try building a (small) molecule of your choice in Avogadro. For now, just use   carbon and hydrogen - we'll look at what we need to do to use different elements   next week. Once you've built a molecule, use it to make a Quantum Espresso input   file and run the calculation.</li> </ul>"},{"location":"labs/lab03/readme/","title":"Convergence and Importance Parameters","text":"<p>In this lab we'll continue looking at molecules, and we'll also be going through how to define various input parameters and how to check how well converged your calculations are.</p> <p>Reminder Don't forget to copy the <code>lab03</code> folder from <code>/opt/Courses/MSE404/lab03</code> to your home directory.</p>"},{"location":"labs/lab03/readme/#linux-recap","title":"Linux Recap","text":"<p>Before you start, if you can't remember how to do something from the command line, this cheat sheet may come in useful. Or you can always refer back to lab 1.</p> <p>Although it's not essential, at some point you may wish to transfer files between different computers. You can do this using the <code>scp</code> command. This website explains how to use it. There are also some other useful commands which we haven't discussed <code>here</code>.</p>"},{"location":"labs/lab03/readme/#pseudopotentials","title":"Pseudopotentials","text":"<p>As discussed in lectures, pseudopotentials are used to approximate the core potential. For each atomic species, you need a file which describes the approximation you want the DFT code to use for that species. As you've seen we set the input files to look in the current directory for the required pseudopotential file. This is done by setting <code>pseudo_dir = '.'</code> in the <code>CONTROL</code> section of the input, where <code>.</code> represents the current directory. We then use a link to this file from some central directory rather than making multiple copies of the pseudopotential for different calculations. This week we'll be doing some different molecules. As always we need to make sure each of the atomic species have a pseudopotential listed in the input file.</p> <p>An alternative way to do this would be to specify the central pseudopotential directory directly in the input file. We've set this in the input file in <code>01_carbon_dioxide/CO2.in</code>.</p> <ul> <li>Take a look at the directory contents and you'll see there's only an   input file there.</li> <li>Compare this to one of the input files from lab 2 and   run the calculation to check it works. Note that you do not need to edit the   file.</li> <li>Take a look at the pseudopotential file we've used for oxygen. The header   has some useful information regarding how the pseudopotential was generated,   such as what states are included, and what approximations are used for   exchange and correlation.</li> </ul>"},{"location":"labs/lab03/readme/#plane-wave-energy-cut-off","title":"Plane-wave energy cut-off","text":"<p>Regardless of the type of system you're looking at, you'll need to check how well converged your result is (whatever it is your calculating) with respect to the plane-wave energy cut-off. This governs how many plane-waves are used in the calculation.</p> <ul> <li>In Quantum Espresso this is controlled with the parameter <code>ecutwfc</code>.</li> <li>Different systems will converge differently - for example you shouldn't   expect diamond and silicon to be converged to the same accuracy with the same   energy cut-off despite having the same structure and same number of   valence electrons.</li> <li>Different pseudopotentials for the same atomic species will also converge   differently. Often pseudopotential files will suggest an energy cut-off.</li> <li>Different calculated parameters will converge differently.<ul> <li>You should be particularly careful when calculating parameters that   depend on volume, as the number of plane-waves for a given energy   cut-off is directly proportional to the volume so this can introduce   an additional variation. We'll see more about this later.</li> </ul> </li> </ul> <p>An example showing the total energy convergence with respect to energy cut-off is in the 02_ecut/01_carbon_dioxide directory. We have already set up a series of input files which are all identical except we systematically increase the value of <code>ecutwfc</code>.</p> <p>Examine one of these input files. You'll notice we've specified some additional variables:</p> <ul> <li>In the <code>CONTROL</code> section we've added the setting <code>disk_io = 'none'</code>. This   suppresses the generation of the wavefunction file and the folder with the   charge density etc. If we only care about the total energy we don't need to   generate these files, and the calculation will run a little faster if it's   not trying to write unnecessary files as disk I/O can often be a bottleneck   in calculations.</li> <li>In the <code>ELECTRONS</code> section we have added the <code>conv_thr</code> setting, though it   is set to its default value. This variable controls when the self   consistency cycle finishes. You should be aware of this variable, as there   is little point in trying to converge to greater accuracy than we are   converging self-consistently.</li> </ul> <p>So now we want to run <code>pw.x</code> for each of these input files. Don't forget you'll need to load the espresso module and its dependencies before the <code>pw.x</code> command will work.</p> <p>It's a little tedious to type out the <code>pw.x</code> command for each input file in turn manually. Instead we can automate this with a small script.</p>"},{"location":"labs/lab03/readme/#shell-scripting","title":"Shell scripting","text":"<p>A shell script is a collection of Linux shell commands in a file, and when that file is executed (in the same way as any Linux command is executed) then those commands are executed. We could make a script that explicitly runs each input file with <code>pw.x</code> in turn as follows:</p> <pre><code>#!/bin/bash\n\n# Run pw.x for each input file sequentially\npw.x &lt; CO2_10.in &amp;&gt; CO2_10.out\npw.x &lt; CO2_15.in &amp;&gt; CO2_15.out\npw.x &lt; CO2_20.in &amp;&gt; CO2_20.out\npw.x &lt; CO2_25.in &amp;&gt; CO2_25.out\npw.x &lt; CO2_30.in &amp;&gt; CO2_30.out\npw.x &lt; CO2_35.in &amp;&gt; CO2_35.out\npw.x &lt; CO2_40.in &amp;&gt; CO2_40.out\n</code></pre> <p>If we save this in a file called say <code>run_set.sh</code> (e.g. by copying the above  to whichever text editor you prefer such as <code>gedit</code>), the simplest way to run the script is using <code>bash run_set.sh</code>, where bash is the default shell on the system  we're using. This means that the same commands you type in a terminal can be used in a bash script. In other words this script does the same thing as if we typed each line directly. It is also possible to execute the script directly using <code>./run_set.sh</code>, which would rquire you to set the file to executable, using <code>chmod</code>.</p> <p>There are also a number of features available in <code>bash</code> to make scripts more general than an explicit set of commands. For example, let's say we want to instead find whatever input files are in the current directory, and run <code>pw.x</code> with them, saving the output in an appropriate file, we could make our script as follows:</p> <pre><code>#!/bin/bash\n\n# Loop over files in the current directory with extension .in\nfor input_file in $(ls *.in)\n   # For each file run pw.x and save output in file with same \n   # root name as input file but with .out extension\n   do\n      pw.x &lt; \"$input_file\" &amp;&gt; \"${input_file%.*}.out\"\ndone\n</code></pre> <p>In this script, we save the output of an <code>ls</code> command listing all the input files with <code>.in</code> extension as a variable. Then we loop over those input files,  running <code>pw.x</code> with each, and saving the output in a file that has the same name as the input file but with the extension <code>.out</code> instead of <code>.in</code>. The part <code>${input_file%.*}</code> returns the value stored in the <code>$input_file</code> variable but with the extension stripped away. This lets us make our script much more general: if we add additional input files, they'll automatically be picked up and run without us needing to modify our script.</p>"},{"location":"labs/lab03/readme/#task","title":"Task","text":"<ul> <li>Save this second script as <code>run_all.sh</code> and run it within the directory    with the carbon dioxide input files using <code>bash run_all.sh</code>.</li> <li>Check one of your output files to make sure Quantum Espresso ran    as expected. If your file contains only an error message, you likely forgot    to load the modules required to use Quantum Espresso on our server.</li> </ul> <p>Once the calculations have run, we want to see how the total energy changes with the input plane-wave energy cut-off. We could go through each output file and find the resulting total energy and gather them in a file, but again that would be tedious so we can write a script to do it for us (or extend our earlier script to also do this).</p> <p>There are two different commands we could use to extract the resulting total energy from file. The first is often simpler to use and is called <code>grep</code>. For example we could use the following to print the line containing the final total energy from each output file using the fact that <code>pw.x</code> helpfully starts this line with a <code>!</code>: <code>grep '^!.*total energy' *out</code>. In particular, we are searching for a line which has the symbol <code>!</code> at the beginning <code>^</code> and that also contains the string <code>total energy</code> in all files whose names end with <code>out</code>. Try running this now in the directory containing your output files.</p> <p>The other command we could use is <code>awk</code>, which is more powerful, but also more complicate to use, and lets us pick out both the total energy value and the energy cut-off that was used with a single command. We could use this in a simple script as follows:</p> <pre><code>#!/bin/bash\n\n# In all files ending with 'out', find line with 'kinetic-energy' \n# and save the fourth column/word into variable 'ecut'. \n# Then in the same file also find a line beginning with '!' and that contains\n# the string 'total' and print the value stored in 'ecut' and the\n# fifth column/word from this line.\nawk '/kinetic-energy/{ecut=$4} /^!.*total/{print ecut, $5}' *out\n</code></pre> <p>Here we use the <code>awk</code> command to find the line with <code>kinetic-energy</code> and save the fourth word (<code>$4</code>) to a variable called <code>ecut</code>. Then when it finds a line that starts with a <code>!</code> and has the word <code>total</code>, it will output the value stored in the <code>ecut</code> variable, followed by the fifth word (<code>$5</code>) on that line.</p>"},{"location":"labs/lab03/readme/#task_1","title":"Task","text":"<ul> <li>Save this as a script called <code>etot_v_ecut.sh</code>, run it in the directory with    the output files and save the output as <code>etot_v_ecut.dat</code>. You can do this    by typing <code>bash etot_v_ecut.sh &gt; etot_v_ecut.dat</code>.</li> <li>Look at the output (e.g. using <code>gedit</code>) and you can see to how many significant    figures the total energy is converged for a given energy cut-off.</li> </ul> <p>We can make things even easier if rather than manually generating all the input files, we modify the script to take a base input file and modify it for each calculation, run it, and finally parse the output to a data file.</p> <p>This is in the <code>02_ecut/02_methane</code> directory.</p> <p>The script is as follows: <pre><code>#!/bin/bash\n\n# Original filename\ntemplate=\"CH4_base.in\"\n# String to be replaced\nrepstr=\"xxxx\"\n\n# Loop from 10 to 50 in steps of 5. These are the values of the energy cut-off\nfor val in {10..50..5}\ndo\n  # Define input file name. Assign at each file a specific name\n  inp=\"CH4_${val}.in\"\n  # Substitute \"xxxx\" string in original file with the current energy cut-off value\n  # and paste the result into new input file\n  sed \"s/$repstr/$val/\" $template &gt; $inp\n  # Run pw.x on the current input file\n  pw.x &lt; $inp &amp;&gt; ${inp%.*}.out\ndone\n\n# Extract for each output file the values of the energy cut-off\n# and the final total energy\n# Paste results in etot_v_ecut.dat file\nawk '/kinetic-energy/{ecut=$4}\n     /^!.*total/{print ecut, $5}' *out &gt; etot_v_ecut.dat\n</code></pre></p> <p>Here we've combined the two scripts we created above, and also automated the generation of input files using the <code>sed</code> command. This can be used to search for and replace some text in a file. We have set up a template input file <code>CH4_base.in</code> where we have used the placeholder text <code>xxxx</code> as the text we'll search for and replace with energy cut-off we want for our input file. The bash construction <code>for val in {10..50..5}</code> will create a loop where the value stored in the variable <code>$val</code> runs from 10 to 50 in steps of 5.</p>"},{"location":"labs/lab03/readme/#task_2","title":"Task","text":"<ul> <li>Run this script and see what input and output files are generated.</li> </ul>"},{"location":"labs/lab03/readme/#plotting-with-gnuplot","title":"Plotting with Gnuplot","text":"<p>It's often useful to be able to generate a quick plot when testing the relation between variables. <code>gnuplot</code> is a useful tool for generating plots, particularly as it is also scriptable, so we could extend our earlier script to automatically generate a plot from from the extracted data. There is a more detailed overview in the gnuplot section.</p> <p>We can launch gnuplot by typing <code>gnuplot</code> in a terminal. Once it opens, we can, for example, plot a data file by typing <code>plot \"etot_v_ecut.dat\"</code> (provided we are in the directory containing that file). This will only plot the points by default. If we want to join these up with lines we can type <code>plot \"etot_v_ecut.dat\" with linespoints</code>, or <code>p \"etot_v_ecut.dat\" w lp</code>. If you want to specify different columns of data, you can do for example <code>p \"etot_v_ecut.dat\" u 2:1 w lp</code> to plot column 2 vs. 1 instead of 1 vs. 2 (which is the default).</p>"},{"location":"labs/lab03/readme/#task_3","title":"Task","text":"<ul> <li>Generate plots of the difference between the total energy and its most   converged value versus plane wave energy cut-off for both methane and   carbon dioxide.<ul> <li>Instead of working out energy differences yourself, you can plot the   difference in energies directly in gnuplot, for example   by doing <code>eref=-100; p \"etot_v_ecut.dat\" u 1:($2-eref) w lp</code>, where    in this case we are calculating the energy relative to -100.   You should change the value of <code>eref</code> from -100 to the energy of   the calculation with the highest plane-wave cut-off.</li> <li>It can also be useful to plot convergence on a logscale, which you can do   in gnuplot by typing <code>set logscale y</code> before you type the above command.</li> </ul> </li> <li>How does the behaviour compare between the two molecules?</li> </ul>"},{"location":"labs/lab03/readme/#exchange-correlation-functional","title":"Exchange &amp; Correlation Functional","text":"<p>The exchange and correlation is a key part of DFT. The functional we use determines how we approximate all the many body interactions. By default, within Quantum Espresso, the exchange and correlation functionals that are used are taken from the header of the pseudopotential file as mentioned above. It's possible to override this using the <code>input_dft</code> variable in the system section, but it's best to use the same approximation as was used in the pseudopotential generation.</p> <p>The exchange correlation can have a big impact on a number of parameters. In this example we consider the example of an argon dimer.  By varying the bond length between two argon atoms we can plot binding energy curves. This is  another example where shell scripting can be very useful, since we want to run several similar calculations. We can modify the script we used for the cut-off energy convergence to do this. We again define a template input file, found in <code>Ar2_base.in</code> and then use the following script, which can be found in the <code>03_argon/01_lda</code> directory. In this case we want more data points in some places than others, so we directly specify each distance we want to calculate. There are also some other differences from the previous script - in this case we take the value of r that we set and directly print it using the command <code>echo</code>, rather than extracting it from the Quantum Espresso output, but otherwise the same principles apply.</p> <p>The script for LDA is as follows: <pre><code>#!/bin/bash\n\n# Original filename\ntemplate=\"Ar2_base.in\"\n# String to be replaced\nrepstr=\"xxxx\"\n\n# delete the file if it exists already (-f)\nrm -f etot_v_r.dat\n\n# Loop over bond lengths\nfor val in 3.0 3.1 3.2 3.3 3.4 3.5 3.6 3.7 3.8 4.0 4.2 4.5 5.0\ndo\n  # Print message to output\n  echo \"Calculating Ar dimer with r=${val}\"\n  # Define input file with specific name\n  inp=\"Ar2_r${val}.in\"\n  # Substitue 'xxxx' string with current bondlength value\n  # and paste result in new input file\n  sed \"s/$repstr/$val/\" $template &gt; $inp\n  # Run pw.x on the new input file and save results in \n  # output file with same rootname as input file\n  pw.x &lt; $inp &amp;&gt; ${inp%.*}.out\n  # Save current bondlength value in etot_v_r.dat file\n  echo -en \"${val}\\t\" &gt;&gt; etot_v_r.dat\n  # Extract cut-off and total energy and append to etot_v_r.dat file\n  awk '/^!.*total/{print ecut, $5}' ${inp%.*}.out &gt;&gt; etot_v_r.dat\ndone\n</code></pre></p>"},{"location":"labs/lab03/readme/#task_4","title":"Task","text":"<ul> <li>Run this script and see what input and output files are generated.<ul> <li>In order to save computer time the box size and cut-off have been   chosen for speed rather than accuracy. If you have time, try converging   these values properly. On the other hand, if the calculations take too   long then reduce the number of data points by removing some distances.</li> </ul> </li> <li>See how the total energy varies with the distance between atoms.</li> </ul> <p>Now we want to try a different functional.  In the directory <code>03_argon/02_pbe</code> an input file is present that is identical to the previous calculation, except we specify a different pseudopotential here: <code>Ar.pbe-n-rrkjus_psl.1.0.0.UPF</code>.</p>"},{"location":"labs/lab03/readme/#task_5","title":"Task","text":"<ul> <li>Look at this file, and compare the header section to the pseudopotential you   used previously. You'll notice a line mentioning \"PBE Exchange-Correlation   functional\" in the pseudopotential we're using here, where it said \"PZ   Exchange-Correlation functional previously\".<ul> <li>Here PZ refers to a particular parametrisation of the Local Density   Approximation (LDA) - the simplest approximation for the exchange and   correlation, while PBE is more advanced approximation (though not   necessarily better performing), which is classed as a Generalized   Gradient Approximation (GGA). The letters PZ and PBE are the initials of   the authors of the papers in which the particular approximations were   published.</li> </ul> </li> <li>Run the script for PBE.</li> <li>Plot distance vs. length for both PBE and LDA using the gnuplot script   <code>plot_ar.gp</code> in the <code>03_argon</code> directory, by typing <code>gnuplot plot_ar.gp</code>. This   will generate a file called <code>ar_dimer.eps</code>. You can view this file for example   using the program <code>evince</code> if you type <code>evince ar_dimer.eps</code>. How do the two   functionals compare?</li> </ul>"},{"location":"labs/lab03/readme/#summary","title":"Summary","text":"<ul> <li>In this lab we looked at defining pseudopotentials, checking the convergence of   the total energy with respect to the plane-wave energy cut-off, and the effect   of exchange and correlation functional.<ul> <li>Convergence of any parameter is done by systematically varying the   corresponding calculation parameter and looking at how the result changes.</li> </ul> </li> <li>We saw how we can use bash scripts to automate this process.<ul> <li>This means we don't need to manually create a number of almost identical   input files, and manually go through each one to find the values we   want.</li> <li>We can use a bash <code>for</code> loop to perform a calculation for a number of   input files.</li> <li>We can use <code>grep</code> or <code>awk</code> to parse results or parameters from our   output files.</li> <li>We can use <code>sed</code> to replace values in a template input file.</li> </ul> </li> <li>We can quickly generate a plot of a data file with <code>gnuplot</code>.</li> </ul>"},{"location":"labs/lab03/readme/#extra","title":"Extra","text":""},{"location":"labs/lab03/readme/#box-size","title":"Box-Size","text":"<p>For systems which are not periodic in three dimensions, such as molecules which  we are calculating within a box, we also need to test the convergence with respect to the box size. In other words, we need to check that the spurious interaction between periodic images is sufficiently small for the accuracy we desire. We would also have to do something similar with for example 2D systems, where we would have empty space in one direction.</p>"},{"location":"labs/lab03/readme/#optional-task","title":"Optional Task","text":"<ul> <li>Create a folder called <code>04_spacing/01_methane_20</code> and test the convergence   of total energy versus box dimension for an energy cut-off of 20 Ry. And   then create a folder called <code>04_spacing/01_methane_60</code> and test the   convergence of total energy versus box dimension for an energy cut-off of 60   Ry.<ul> <li>How do these compare?</li> </ul> </li> </ul>"},{"location":"labs/lab03/readme/#advanced-shell-scripting","title":"Advanced Shell scripting","text":"<p>If you're interested in reading more about scripting, you can take a look at the shellscripting section. We'll provide plenty of examples and keep things relatively simple in the course, but you may find some of the more advanced functionality useful in your own work.</p>"},{"location":"labs/lab04/readme/","title":"Crystals and Electronic Band Structures","text":"<p>This week we are going to start doing some calculations on solids, i.e., periodic crystals. Many of the principles will be the same, but as you will see there are a few things that need to be done differently.</p>"},{"location":"labs/lab04/readme/#structure-and-basic-input-for-diamond","title":"Structure and Basic input for Diamond","text":"<p>As our first example of a solid we're going to look at diamond. You can find an annotated input file at  C_diamond_detailed.in, here I'll give a brief overview of the input file:</p> <p>Tip: In-code annotations</p> <p>Click (1) to see notes on the input tags.</p> <ol> <li>This is an annotation.</li> </ol> <pre><code>&amp;CONTROL\n   pseudo_dir = '.' \n   disk_io = 'none' \n/\n\n&amp;SYSTEM\n   ibrav = 2 #(1)!\n   A = 3.567\n   nat = 2\n   ntyp = 1\n   ecutwfc = 20.0\n/\n\n&amp;ELECTRONS\n   conv_thr = 1.0E-6\n/\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal #(2)!\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\nK_POINTS automatic #(3)!\n  4 4 4 1 1 1\n</code></pre> <ol> <li><code>ibrav=2</code> specifies a FCC unit cell (for a complete list of <code>ibrav</code>, see     input     descriptions).</li> <li><code>crystal</code> specifies that the atomic positions are given in fractional     coordinates of the unit cell vectors (defined by <code>ibrav</code> and     <code>A</code>).</li> <li>We are using automically generated k-point grid with a 4\\(\\times\\)4\\(\\times\\)4     grid size (<code>1 1 1</code> means to shift the grid by 1 grid point in each     direction).</li> </ol>"},{"location":"labs/lab04/readme/#periodic-boundary-conditions-and-atomic-positions","title":"Periodic Boundary Conditions and Atomic Positions","text":"<p>Now we are going to look at how the atomic positions in the input file are specified. </p> <p>Absolute Cartesian coordinates \\(\\mathbf{r}=[x,y,z]\\) and fractional coordinates  \\(\\mathbf{r}_f=(x_f,y_f,z_f)\\) are related by the three lattce vectors \\(\\mathbf{a},\\mathbf{b},\\mathbf{c}\\) as follows:</p> \\[ \\begin{align*} \\mathbf{r}_f &amp;= \\mathbf{r} \\cdot [\\mathbf{a},\\mathbf{b},\\mathbf{c}]\\\\ &amp;=x\\mathbf{a} + y\\mathbf{b} + z\\mathbf{c}  \\end{align*} \\] <p>For diamond, which has the same atomic structure as Zinc Blende, the primitive cell of diamond looks like the following:</p> <p>To specify the primitive cell shape, we first set <code>ibrav=2</code>, i.e. face-centred cubic (fcc) Bravais lattice. Internally, with <code>ibrav=2</code>, Quantum ESPRESSO sets the the fcc lattice vectors as:</p> \\[ \\begin{align*} \\mathbf{v}_1 &amp;= \\frac{A}{2}(-1,0,1)\\\\ \\mathbf{v}_2 &amp;= \\frac{A}{2}(0,1,1)\\\\ \\mathbf{v}_3 &amp;= \\frac{A}{2}(-1,1,0) \\end{align*} \\] <p>Warning</p> <p>Note that we've just used the measured lattice constant <code>A</code>. In later labs (or in production runs) we'll see how to find the lattice  constant predicted by DFT.</p> <p>Under this basis, the fractional coordinates of the two carbon atoms are:</p> \\[ \\begin{align*} \\mathbf{r}_f^{C1} &amp;= (0,0,0) \\\\ \\mathbf{r}_f^{C2} &amp;= (\\frac{1}{4},\\frac{1}{4},\\frac{1}{4}) \\end{align*} \\] <p>Hence, the absolute Cartesian coordinates for the two carbon atoms are given by:</p> \\[ \\begin{align*} \\mathbf{r}^{C1} &amp;= \\frac{A}{2}(-1,0,1) \\times 0 + \\frac{A}{2}(0,1,1) \\times 0 + \\frac{A}{2}(-1,1,0) \\times 0\\\\  &amp;= (0,0,0)\\\\ \\mathbf{r}^{C2} &amp;= \\frac{A}{2}(-1,0,1) \\times \\frac{1}{4} + \\frac{A}{2}(0,1,1)  \\times \\frac{1}{4}+ \\frac{A}{2}(-1,1,0) \\times \\frac{1}{4} \\\\ &amp;= (\\frac{A}{4},\\frac{A}{4},\\frac{A}{4}) \\end{align*} \\] <p>Task 1 - Examining input &amp; output files</p> <p>Run the input file for diamond. There are a couple of extra things to notice in the output file:</p> <ul> <li> <p>The output lists the automatically generated k-points. How many k-points    are there and why?</p> Answer <p>We have 10 here since crystal symmetries have been taken into  account after generating the 64 points on the 4x4x4 grid we requested.</p> </li> <li> <p>What are the eigenvalues and occupations?</p> Answer <p>For periodic systems, we have a set of band energies for each  k-point. And these are given in the output file: <pre><code>      k =-0.1250 0.1250 0.1250 (   116 PWs)   bands (ev):\n\n-7.3461  11.5621  13.5410  13.5410\n\n      k =-0.3750 0.3750-0.1250 (   116 PWs)   bands (ev):\n\n-5.1246   6.0725   9.6342  12.3836\n\n      k = 0.3750-0.3750 0.6250 (   117 PWs)   bands (ev):\n\n-2.0454   1.1023   9.9094  10.6497\n\n      k = 0.1250-0.1250 0.3750 (   120 PWs)   bands (ev):\n\n-6.2574   8.8031  11.2205  12.0763\n\n      k =-0.1250 0.6250 0.1250 (   118 PWs)   bands (ev):\n\n-4.0419   6.4510   8.7237   9.1414\n\n      k = 0.6250-0.1250 0.8750 (   111 PWs)   bands (ev):\n\n 0.0174   2.6697   5.4037   7.5509\n\n      k = 0.3750 0.1250 0.6250 (   115 PWs)   bands (ev):\n\n-2.9709   4.0228   7.6281   9.9651\n\n      k =-0.1250-0.8750 0.1250 (   114 PWs)   bands (ev):\n\n-0.7739   3.2191   6.5088   8.0627\n\n      k =-0.3750 0.3750 0.3750 (   114 PWs)   bands (ev):\n\n-4.0297   3.1416  11.7036  11.7036\n\n      k = 0.3750-0.3750 1.1250 (   114 PWs)   bands (ev):\n\n-1.0562   2.2032   6.0516   9.9570\n</code></pre></p> </li> </ul>"},{"location":"labs/lab04/readme/#convergence-tests","title":"Convergence Tests","text":"<p>One important difference between periodic crystals and molecules is that, due to periodic boundary conditions, the electronic states are not localised and need to be expressed in a Bloch form: </p> \\[ \\psi_{n\\mathbf{k}}(\\mathbf{r}) = e^{i\\mathbf{k}\\cdot\\mathbf{r}}u_{n\\mathbf{k}}(\\mathbf{r}), \\] <p>where the electronic states are labelled by both the band index \\(n\\) and the k-point \\(\\mathbf{k}\\). \\(\\mathbf{k}\\) needs to be sampled over the entire Brillouin zone. Hence a convergence test with respect to the k-point sampling is also necessary for periodic systems.</p> <p>To test the convergence with respect to the k-point sampling, we need to calculate the total energy for different k-point grid densities. The directory <code>02_convergence</code> contains input files and script  k_conv.sh that does this.</p> <p>Task 2 - Convergence with respect to k-point sampling and cut-off energy</p> <ul> <li> <p>Understand and run the script, and plot the convergence of total energy    with respect to k-point sampling. </p> Result <p> </p> </li> <li> <p>For every periodic system you simulate, you should converge both the   cut-off energy and k-points. Try adapting one of the scripts to also    converge the energy of silicon with respect to the cut-off energy. How    does the convergence behaviour of the two parameters compare?</p> Answer <p>An example script to do this is given below:</p> <pre><code>#!/bin/bash\n\ntemplate=\"C_diamond_base_kE.in\"\nrepstr_k=\"xxxx\"\nrepstr_E=\"eeee\"\n\nfor val_k in {02..10..2} #(1)!\ndo\nfor val_E in {20..100..20} #(2)!\ndo\n  echo \"Running for k = $val_k and E = $val_E\"\n  inp=\"C_diamond_${val_k}_${val_E}.in\"\n  sed \"s/$repstr_k/$val_k/g\" $template &gt; $inp #(3)!\n  sed -i \"s/$repstr_E/$val_E/g\" $inp\n  pw.x &lt; $inp &amp;&gt; ${inp%.*}.out_conv_kE\ndone\ndone\n\nawk '/number of k points/{nkpt=$5}/kinetic-energy cutoff/{ekin=$4}\n     /^!.*total/{print nkpt, ekin, $5}' *out_conv_kE &gt; etot_v_nkpt_ekin.dat\n</code></pre> <ol> <li>This loop will run for k-points from 2 to 10 in steps of 2.</li> <li>This loop will run for cut-off energies from 20 to 100 in steps     of 20.</li> <li><code>g</code> here means to replace every entry on the line (global).</li> </ol> <p>You can change the range of k-points and cut-off energies yourself.</p> </li> </ul>"},{"location":"labs/lab04/readme/#the-electronic-band-structure","title":"The Electronic Band Structure","text":"<p>While the electronic density obtained from DFT is meaningful, the Kohn-Sham states are not strictly the electronic states of the system. Nonetheless, they are in practice often a good first approximation of the electronic states of a system, so can be useful in understanding the properties of a system.</p> <p>We have now seen how to converge our calculations with respect to the sampled k-point grid density. And you'll have seen in the calculations you have done that the calculated eigenvalues are a bit different at each calculated k-point. </p> <p>Examining how the state energies change from one k-point to the next can tell us useful things such as if a material is likely to have a direct or indirect optical gap for example. For this we need to visualize how the energies of the states vary with k-point. The usual way this is done is to plot the band energies along lines between the various high-symmetry k-points in the Brillouin zone. The details of how this can be done is beyond the scope of this course, but an outline is given  here.</p> <p>The directory <code>03_bandstructure</code> contains input files to calculate and plot the band structure of diamond. This a four-step process:</p>"},{"location":"labs/lab04/readme/#step-1-scf-calculation","title":"Step 1 - SCF Calculation","text":"<p>Calculate a converged density with a standard  self-consistent field (SCF) calculation. In this step, the charge density is optimized in order to minimize the total energy of the system. The input file can be found at 01_C_diamond_scf.in. </p> <p>Task 3.1 - SCF Calculation</p> <p>Run the input file 01_C_diamond_scf.in for diamond.</p>"},{"location":"labs/lab04/readme/#step-2-nscfbands-calculation","title":"Step 2 - NSCF(bands) Calculation","text":"<p>Use that density to perform a non self-consistent (NSCF) calculation for k-points along chosen high-symmetry lines. In an NSCF calculation, the energy is not minimised as the charge density is read-in and kept fixed. Instead  the Kohn-Sham energies and states for a particular k-point are calculated by diagonalizing the Hamiltonian generated by the charge density. </p> <p>For this to work, we need to choose a set of high symmetry k-points for carbon diamond. Since diamond has a face-centred cubic (FCC) lattice, we have chosen the path <code>\u0393-K-X-\u0393'-L-X-W-L</code> where <code>\u0393'</code> indicates the gamma point in a different Brillouin zone.</p> <p>A brief overview of the   input file is  given below:</p> <pre><code>&amp;CONTROL\n pseudo_dir = '.'\n calculation = 'bands' #(1)!\n/\n\n&amp;SYSTEM\n   ibrav =  2\n   A = 3.567\n   nat =  2\n   ntyp = 1\n   ecutwfc = 30.0\n   # Add 4 conduction bands also\n   nbnd = 8 #(2)!\n/\n\n&amp;ELECTRONS\n/\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\n# Path here goes: G K X G' L X W L\nK_POINTS crystal_b #(3)!\n  8\n  0.000 0.000 0.000 30\n  0.375 0.375 0.750 10\n  0.500 0.500 1.000 30\n  1.000 1.000 1.000 30\n  0.500 0.500 0.500 30\n  0.000 0.500 0.500 30\n  0.250 0.500 0.750 30\n  0.500 0.500 0.500 0\n</code></pre> <ol> <li><code>calculation = 'bands'</code> specifies that we are calculating the band     structure.</li> <li><code>nbnd = 8</code> specifies that we want to calculate 8 bands. 4 more bands than     the default value of 4.</li> <li><code>K_POINTS crystal_b</code> specifies that we are using the high symmetry k-points     in the reciprocal lattice coordinates. The number of high symmetry points     is given as 8, followed by the coordinates of each point and the number of     points to generate between it and the next point.</li> </ol> <p>Task 3.2 - NSCF Calculation</p> <p>Run the input file 02_C_diamond_nscf.in for diamond.</p>"},{"location":"labs/lab04/readme/#step-3-extracting-band-energies","title":"Step 3 - Extracting Band Energies","text":"<p>Extract the energies from this calculation and convert it to a dataset we can  plot.</p> <p>To do this, we use the <code>bands.x</code> tool from the Quantum Espresso package. The  input file for this contains only a <code>BANDS</code> section. For more fine-grained control please refer to   bands.x input description.</p> <p>Task 3.3 - Extracting band energies</p> <p>Run the input file 03_C_diamond_bands.in for diamond.</p>"},{"location":"labs/lab04/readme/#step-4-plotting-the-band-structure","title":"Step 4 - Plotting the Band Structure","text":"<p>Plot the band structure. The band structure is usually plotted with the energy on the y-axis and the high symmetry points on the x-axis. The energy is usually shifted so that the valence band maximum is at 0 eV. The directory <code>03_bandstructure</code> contains a gnuplot script plotbands.gplt that can be used to plot the band structure:</p> <pre><code>set encoding utf8 # This lets us use the Gamma symbol directly\n\n# The locations of the tics are given in the output of the bands.x calculation\nset xtics (\"\u0393\" 0.0000, \"K\" 1.0607,\"X\" 1.4142, \"\u0393\" 2.4142, \"L\" 3.2802, \"X\" 4.1463, \"W\" 4.6463, \"L\" 5.3534)\n\n# This gives us a full vertical line\nset grid xtics lt -1 lw 1.0\n\n# We don't need a legend\nunset key\n\n# set a label and a title\nset ylabel \"Energy (eV)\"\nset title \"Carbon Diamond Electronic Band Structure\"\n\n# This tells gnuplot to plot all the points from this file connected with lines\n# We modify the y values to shift the valence band max at gamma to 0.\nplot \"bands.out.gnu\" using 1:($2-13.993) with lines !(1)\n\n# And if you run this script directly as an argument to gnuplot, rather than\n# by loading it within gnuplot, you can uncomment the following to keep the\n# plot window open until clicked. You can save to a file from here.\n# pause mouse\n\nset term pdf\nset output \"C_diamond_bands.pdf\"\nreplot\n</code></pre> <p>The valence band max was at gamma (the first point on our path), we could read the value of the energy at this point from one of the other output files, <code>bands.out</code>. And here we shift the entire spectrum so that this point is at 0 eV using <code>($2-13.993)</code>.</p> <p>Task 3.4 - Plotting the band structure</p> <p>Run the gnuplot script plotbands.gplt to plot the band structure of diamond.</p> Final result <p> </p>"},{"location":"labs/lab04/readme/#density-of-states","title":"Density of States","text":"<p>Now let's analyse the electronic states by computing the density of states (DOS). This is a little easier to visualise and shows how many electronic states (in fact Kohn-Sham states for our DFT calculation) are at a given energy. More precisely, the DOS tells us how many electronic states, for a system of volume V, can be occupied in a small (infinitesimal) energy range near a specific energy. </p> <p>The DOS is directly related to the band structure as:</p> \\[ \\mathrm{DOS}(E) = \\sum_{n} \\int  \\delta(E - \\epsilon_{n\\mathbf{k}}) d\\mathbf{k} \\] <p>where \\(\\epsilon_{n\\mathbf{k}}\\) are the Kohn-Sham eigenvalues for band \\(n\\) and k-point \\(\\mathbf{k}\\).</p> <p>Hence, bands with large energy dispersion in the Brillouin zone result in low DOS, whereas less dispersive (more flat) bands result in high DOS. In insulators and semiconductors the DOS is zero inside the band gap, as there are no available states in that energy range. </p> <p>However, since we can only have a finite sampling of the Brillouin zone we need to interpolate the results in some sensible way if we turn this into a count of the total number of states at an arbitrary energy.</p> <p>The most common way this is done is to use some energy broadening scheme, i.e., boradening the delta function. Doing this, we can include some contributions from k-points that we missed. In practice this is quite fast and straight-forward, although you'll need to tune the broadening energy so that your calculated density of states is smooth in the correct way: </p> <ul> <li>If you use too large a broadening, you may smear out important   features.</li> <li>If you use too small a broadening you may introduce spurious features   and your density of states plot will look very bumpy.</li> <li>In principle you would want the smearing to be comparable to the   typical change in energy of a state from a k-point to its neighbours.   In practice though it's easiest to just try different values until it   looks right.</li> </ul> Tetrahedron Method <p>The other way to interpolate is to use the so-called tetrahedron method. Essentially this corresponds to doing a three dimensional linear interpolation from a regular grid of values. This calculation can be noticeably slower than using a broadening but there is no need to to worry about using the correct smearing. The density of states will simply become more finely featured as you increase the density of the k-point grid in the non-self-consistent calculation.</p> <p>It's important to note that in a real measurement of the density of states of a system the there is an implicit broadening that comes from</p> <ol> <li> <p>Electron-phonon coupling: the states are not simply at a fixed   energy, but will have some distribution as the atoms vibrate.</p> </li> <li> <p>Any measurement probe will have a finite energy width associated   with it, which will limit how finely it can resolve density of states   features.</p> </li> </ol> <p>So while tetrahedron may seem the more accurate approach, you shouldn't necessarily think of it as a more correct representation of a real system.</p> <p>In a similar way to the electronic band structure, we produce the density of  states plot in three steps.</p>"},{"location":"labs/lab04/readme/#step-1-scf-calculation_1","title":"Step 1 - SCF Calculation","text":"<p>Perform a self consistent calculation as before, producing a converged charge density.</p> <p>Task 4.1 - SCF Calculation</p> <p>Run the input file 01_C_diamond_scf.in for diamond.</p>"},{"location":"labs/lab04/readme/#step-2-nscf-calculation","title":"Step 2 - NSCF Calculation","text":"<p>Take the density calculated in the previous step and use it to perform a non-self-consistent calculation on a more dense grid of k-points. We want a good representation of how the state energies vary as we move around the Brillouin zone so we use a much denser grid here than we need to obtain a converged density in the previous step.</p> <p>The difference between this and the band structure calculation is that here we use a uniform sampling of the Brillouin zone, rather than a path between k-points. The input file for this calculation can be found at 02_C_diamond_nscf.in:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n    calculation = 'nscf' #(1)!\n /\n\n &amp;SYSTEM\n    ibrav =  2\n    A = 3.567\n    nat =  2\n    ntyp = 1\n    ecutwfc = 60.0\n    # Add 4 conduction bands also\n    nbnd = 8 #(2)!\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n C  12.011  C.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal\n C 0.00 0.00 0.00\n C 0.25 0.25 0.25\n\nK_POINTS automatic #(3)!\n  20 20 20  0 0 0\n</code></pre> <ol> <li><code>calculation = nscf</code> specifies that we are calculating the      non-self-consistent calculation.</li> <li><code>nbnd = 8</code> specifies that we want to calculate 8 bands.</li> <li><code>K_POINTS automatic</code> specifies that we are using an automatically generated     k-point grid. We've increased the k-point sampling to a 20x20x20 grid, and      we have removed the shift. Many systems have a valence band maximum or     conduction band minimum at the gamma point, so it is good to ensure it's     explicitly included in the grid.</li> </ol> <p>Task 4.2 - NSCF Calculation</p> <p>Run the input file 01_C_diamond_scf.in for diamond.</p>"},{"location":"labs/lab04/readme/#step-3-density-of-states-calculation","title":"Step 3 - Density of States Calculation","text":"<p>Convert the state energies calculated on this dense k-point grid to a density of states using <code>dos.x</code>.  03_C_diamond_dos.in is the input file for <code>dos.x</code>. This code input file requires just a <code>DOS</code> section:</p> <pre><code> &amp;DOS\n  degauss = 0.03 #!(1)!\n  DeltaE = 0.1 #(2)!\n /\n</code></pre> <ol> <li><code>degauss</code> specifies the Gaussian broadening to use in the density of states     calculation. This is in Rydberg.</li> <li><code>DeltaE</code> specifies the spacing between points in the output file, in eV.</li> </ol> <p>Note</p> <p>we've picked values for these of similar magnitude despite their different  units. In fact if <code>degauss</code> is not specified, and no broadening scheme is  used in the DFT calculation, <code>degauss</code> will take the value of <code>DeltaE</code> by  default. You can check the documentation file <code>INPUT_DOS.txt</code> for more  details.</p> <p>Task 4.3 - Density of States Calculation</p> <p>Run the input file 03_C_diamond_dos.in for diamond.</p> <p>The final step produces a file named <code>pwscf.dos</code> by default. This is a simple text file you can plot in whatever software you like. It has three columns:</p> <ol> <li>Energy (eV)</li> <li>Density of States (states/eV)</li> <li>Integrated Density of States (states)</li> </ol> <p>It is customary to shift the x-axis in the plot such that the Fermi energy or valence band max is at 0. While a value for the Fermi level is given in the file header of the generated <code>pwscf.dos</code>, this is determined in a simple way from the integrated density of states. It may be worth obtaining this from a separate calculation using a relatively small broadening if you're looking a metallic system, while for semiconductors and insulators you could find the maximum valence band state energy manually. </p> <p>If you're plotting in gnuplot you can shift the x-axis origin within the plot command:</p> <p><pre><code>plot \"pwscf.dos\" using ($1-13.180):2 with lines\n</code></pre> Where we have used <code>13.180</code> as the value of the Fermi energy. If you want to plot the integrated DOS using the right hand axis you can do the following: <pre><code>set ytics nomirror\nset y2tics\nset xlabel \"Energy (eV)\"\nset ylabel \"Density of states\"\nset y2label \"Integrated density of states\"\nset key top left\nplot \"pwscf.dos\" using ($1-13.180):2 with lines title \"Density of States\", \\\n     \"pwscf.dos\" using ($1-13.180):3 axes x1y2 with lines title \\\n     \"Integrated density of states\"\n</code></pre></p> <p>Task 4.4 - Density of States Calculation</p> <p>Plot the density of states using the script provided.</p> Final result <p> </p>"},{"location":"labs/lab04/readme/#summary","title":"Summary","text":"<ul> <li>In this lab we looked at how to calculate:<ul> <li>k-point convergence in solids.</li> <li>the electronic band structure of a solid.</li> <li>the electronic density of states of a solid.</li> </ul> </li> <li>We have seen how several calculations may be chained together where the   output of one is used as an input for a subsequent calculation.</li> <li>We have used the <code>bands.x</code> and <code>dos.x</code> codes from the Quantum Espresso   package.</li> <li>We have done some more plotting in gnuplot.</li> <li>We should always keep in mind that the Kohn-Sham eigenvalues as obtained   from a DFT calculation do not correspond to the real interacting electron   energy levels, but are often useful as a first approximation.</li> </ul>"},{"location":"labs/lab05/readme/","title":"Forces, Stresses and Structures","text":"<p>Reminder Don't forget to copy the <code>lab05</code> folder from <code>/opt/Courses/MSE404/lab05</code></p> <p>To find the minimum energy position of an atom, we could manually move it, calculating the total energy each time, effectively finding the position where the total force on it is zero. Some examples of how you can do this are given here, you can take a look through in your own time if you're interested. Instead, in this lab we'll be looking at how forces and stresses can be calculated within DFT at essentially no extra cost via the Hellman-Feynman theorem, and how these can be used.</p> <p>In Quantum Espresso you can enable the calculation of forces and stresses by setting <code>tprnfor = .true.</code> and <code>tstress = .true.</code> respectively in the <code>CONTROL</code> section of the input file.</p>"},{"location":"labs/lab05/readme/#forces-in-methane","title":"Forces in Methane","text":"<p>As a first example, let's look at methane and calculate how the forces converge with planewave energy cut-off. We have set up a template input file as before in <code>01_forces/01_methane/CH4_base.in</code>. Take a look at this now. The only new settings here are the two additional variables mentioned above.</p> <p>We also have a simple script to run this template file with energy cut-off values from 20 to 60 Ry as <code>auto_run.sh</code>. Run this now and take a look at one of the output files. You'll see before the final timing information a section that looks like the following:</p> <pre><code>     Forces acting on atoms (cartesian axes, Ry/au):\n\n     atom    1 type  1   force =     0.00000620    0.00000000    0.00002841\n     atom    2 type  2   force =     0.00000137    0.00000000    0.01218625\n     atom    3 type  2   force =     0.01151561    0.00000000   -0.00407450\n     atom    4 type  2   force =    -0.00576159   -0.00997884   -0.00407008\n     atom    5 type  2   force =    -0.00576159    0.00997884   -0.00407008\n\n     Total force =     0.024421     Total SCF correction =     0.000247\n\n\n     Computing stress (Cartesian axis) and pressure\n\n          total   stress  (Ry/bohr**3)                   (kbar)     P=   -0.06\n  -0.00000044   0.00000000   0.00000000         -0.06      0.00      0.00\n   0.00000000  -0.00000044   0.00000000          0.00     -0.06      0.00\n   0.00000000   0.00000000  -0.00000044          0.00      0.00     -0.06\n</code></pre> <p>So we have a list of the components of the force acting on each atom along Cartesian axes, then a total force and total scf correction. Note the <code>Total force</code> listed here is the square root of the sum of all of the force components squared rather than the sum of the magnitudes of the individual forces on the atoms. I'm not sure why, but it's likely because the number is intended more as a guide to check overall accuracy. If the <code>Total SCF correction</code> is comparable to the <code>Total force</code> it usually means you need to try to better converge the SCF cycle (via <code>conv_thr</code>).</p> <p>Following this we can see the calculated stress and corresponding pressure on the unit cell. While this number doesn't mean much in principle for a calculation on a molecule in a box, if these numbers are not all close to zero it indicates your box size is likely not big enough.</p>"},{"location":"labs/lab05/readme/#convergence","title":"Convergence","text":"<p>Now let's look at the convergence of the forces. As we've been doing in previous labs, we can extract the total force as a function of the energy cut-off using <code>awk</code>:</p> <p><pre><code>awk '/kinetic-energy/{ecut=$4} /Total force/{print ecut, $4}' *out\n</code></pre> This works by saving (space delimited) field number 4 as a variable <code>ecut</code> on a line containing the string <code>kinetic-energy</code>, and then on a line containing the text <code>Total force</code> it outputs the value of this variable along with the text in the fourth field.</p> <p>We could modify this to also output the total energy as <pre><code>awk '/kinetic-energy/{ecut=$4}\n     /!.*total/{etot=$5}\n     /Total force/{print ecut, etot, $4}' *out\n</code></pre> (You can add line breaks for clarity within an awk command if it gets long).</p> <p>And add in the total pressure also with <pre><code>awk '/kinetic-energy/{ecut=$4}\n     /!.*total/{etot=$5}\n     /Total force/{totfor=$4}\n     /total.*stress/{print ecut, etot, totfor, $6}' *out\n</code></pre></p> <p>Try running this and saving the convergence to a file.</p>"},{"location":"labs/lab05/readme/#task","title":"Task","text":"<ul> <li>Plot the fractional difference with respect to the most well converged   result, i.e. \\(|\\frac{x_{conv} - x_i}{x_{conv}}|\\), for each of total energy,    total force and pressure as a function of energy cut-off.</li> <li>What can you see about the rate of convergence of each of these parameters?</li> </ul>"},{"location":"labs/lab05/readme/#optimizing-ionic-positions-ppp","title":"Optimizing Ionic Positions - PPP","text":"<p>Now let's look at a polymer, in this case poly(para-phenylene) (PPP), which consists of a chain of benzene rings, with a torsion angle of \\(\\theta\\), which should be around \\(30^{\\circ}\\). If we wanted to predict the value of \\(\\theta\\), we could take structures with a few different angles and find the minimum of the energy by fitting a parabola.  In the directory <code>02_structure/01_ppp</code> there are some input files for different torsion angles, where e.g. <code>02_structure/01_ppp/PPP_30.in</code> corresponds to \\(\\theta=30^{\\circ}\\). Since the polymer is periodic in only 1 dimension (the z axis), we have added empty space in the other two directions. We have also added k-point sampling along the z-axis only.</p>"},{"location":"labs/lab05/readme/#task_1","title":"Task","text":"<ul> <li>Run the input files for PPP for angles of 20, 25, 30, 35 and 40 degrees. Try writing a script   to automate the process. Your script should generate an output file called <code>e_v_theta.txt</code>   which has two columns - the first should be the torsion angle and the second should be the   calculated energy.</li> <li>Use the file <code>plot_ppp.gp</code> to plot energy vs. \\(\\theta\\). This will generate a file called   <code>ppp.eps</code>, where a quadratic function has been fit to the data. Using this fit, work out   what the optimum torsion angle is.</li> </ul> <p>While the above approach gives us a good idea of the optimum torsion angle, it's a bit tedious to generate the input structures, and it doesn't tell us whether or not the benzenes remain rigid, or if there are some internal distortions. To tell us this, we can use the forces. In fact, given that we can readily calculate forces, wouldn't it be nice if the code could automatically use these forces and find the atomic positions where these forces are zero (or at least within some tolerance of zero)?</p> <p>In Quantum Espresso this type of calculation, where the atomic positions are relaxed to their minimum energy positions can be performed by selecting <code>calculation = 'relax'</code> in the <code>CONTROL</code> section. There are a number of additional variables that you can specify to control this process:</p> <ul> <li><code>tprnfor</code> is automatically set to <code>.true.</code> so that forces are computed.</li> <li>You'll need to add an <code>IONS</code> section to the input. This is the only   mandatory addition. There are several variables that can be specified within   this section (it can be empty if you're happy with all defaults), which   control the algorithm used to find the optimal ionic positions. Consult the   PW documentation for details.</li> </ul>"},{"location":"labs/lab05/readme/#task_2","title":"Task","text":"<p>The directory <code>02_structure/01_ppp</code> also contains an input file 02_structure/01_ppp/PPP_opt.in for relaxing the structure of PPP, where we start from the \\(\\theta=30^{\\circ}\\) structure since this is close to the minimum. Run this and take a look at the output file once the  calculation finishes - it might take a couple of minutes. The interesting bit is right near the end, just before the timing output. It should look something like the following: <pre><code>     Forces acting on atoms (cartesian axes, Ry/au):\n\n     atom    1 type  1   force =     0.00001266    0.00000665   -0.00024259\n     atom    2 type  1   force =     0.00066443    0.00046526    0.00036559\n     atom    3 type  1   force =    -0.00064066   -0.00045488    0.00039018\n     atom    4 type  1   force =     0.00066443    0.00046526   -0.00036559\n     ....\n     atom   17 type  2   force =     0.00017760    0.00095599   -0.00028356\n     atom   18 type  2   force =    -0.00020428   -0.00097249   -0.00028734\n     atom   19 type  2   force =     0.00017760    0.00095599    0.00028356\n     atom   20 type  2   force =    -0.00020428   -0.00097249    0.00028734\n\n     Total force =     0.003777     Total SCF correction =     0.000132\n\n     bfgs converged in   6 scf cycles and   5 bfgs steps\n     (criteria: energy &lt;  1.0E-04 Ry, force &lt;  1.0E-03 Ry/Bohr)\n\n     End of BFGS Geometry Optimization\n\n     Final energy   =    -144.7886351866 Ry\nBegin final coordinates\n\nATOMIC_POSITIONS (bohr)\nC        6.140945672   6.140862654   1.381651769\nC        6.169063980   3.869814143   2.732426642\nC        6.112760385   8.411811375   2.732410276\nC        6.169063980   3.869814143   5.337957358\n....\nH        8.194183393   2.617484701   9.770830680\nH        4.087214702   9.663976947   9.770881223\nH        8.194183393   2.617484701  14.440322320\nH        4.087214702   9.663976947  14.440271777\nEnd final coordinates\n</code></pre></p> <ul> <li>We have the force output. They should all be pretty close to zero now.</li> <li>Then it should say that our relaxation converged (<code>bfgs</code> is the name of the   default algorithm used) and how many steps it took.</li> <li>We have the final total energy output.</li> <li>Finally we have the optimized atomic positions. </li> </ul> <p>In order to be sure we have accurately relaxed the structure, we should converge the forces with respect to cut-off energy, k-points and x and y cell dimensions. There are also some variable which affect when the calculation stops. These include</p> <ul> <li><code>etot_conv_thr</code> and <code>forc_conv_thr</code>, which are used to determine when the optimization   finishes (listed following <code>criteria:</code> in the output above) and</li> <li><code>conv_thr</code>, which as we've already seen is the scf convergence criteria.</li> </ul>"},{"location":"labs/lab05/readme/#task_3","title":"Task","text":"<ul> <li>Open the output file in <code>xcrysden</code>. As you will see, it's possible to just open the   final optimized structure, or load the optimization as an animation. Since we already   started quite close to the final structure, you won't see much of a change if you   watch an animation.</li> <li>Use the <code>dihedral angle</code> option in xcrysden to find the torsion angle of the relaxed   structure. How does this compare to what you previously predicted?</li> </ul>"},{"location":"labs/lab05/readme/#fixing-some-atoms-methane","title":"Fixing Some Atoms - Methane","text":"<p>Finally, it's useful to know that we can also optimize the positions of selected atoms within a system, keeping some atoms fixed.  The input file 02_structure/02_methane/CH4.in shows how this works for the example of methane.</p>"},{"location":"labs/lab05/readme/#optional-task","title":"Optional Task","text":"<ul> <li>Take a look at the input file.</li> <li>We've added some 1s and 0s following the atomic positions. These define   multiplying factors for the various calculated force components on an atom.<ul> <li>By adding three 0s following the carbon position we ensure it will be   fixed at 0,0,0.</li> <li>We only allow the first H atom to move along the z-axis.</li> <li>And we only allow the second H atom to move within the x-z plane.</li> </ul> </li> <li>Run <code>pw.x</code> with this input file and check the result.</li> <li>Has the C-H bond been lengthened or shortened?</li> <li>How much lower is the total energy compared to the starting configuration?</li> <li>Perform this calculation for energy cut-offs of 10 and 50 Ry, and see how   this affects predicted C-H bond length.</li> <li>What do you think would happen if you did this calculation for carbon   diamond? What about graphite?</li> </ul>"},{"location":"labs/lab05/readme/#optimizing-unit-cells","title":"Optimizing Unit Cells","text":"<p>In a similar way to using the calculated forces to optimize the ionic positions we can also use the calculated stresses to optimize the unit cell. In doing this you should keep in mind that it can take a higher energy-cut off to converge the stress as we saw at the start of this lab. Also, if you recall the number of planewaves depends on the cell volume, so if during the course of the calculation we change the volume we may also change the number of plane waves, or if we fix the number of plane waves we are changing the effective energy cut-off (the latter for Quantum Espresso, but different codes will handle this differently). So you need to be quite careful about this when optimizing lattice vectors.</p> <p>In Quantum Espresso we can do this variable-cell relaxation by setting <code>calculation = 'vc-relax'</code> in the <code>CONTROL</code> section. We must additionally specify both an <code>IONS</code> section as previously, along with a <code>CELL</code> section.</p> <p>An example input file for silicon is given in the directory <code>02_structure/03_silicon</code>. Take a look at this now. You'll notice in addition to the inputs mentioned, there's also a fairly high energy cut-off, and we've lowered the SCF convergence threshold from the default. Try running this now and let's look at the output.</p> <p>The output is a little different in this case, since at the end of the optimization, an <code>scf</code> calculation is automatically performed starting from the optimized structure. This is because Quantum Espresso fixes the basis set as that for the original input structure during the calculation, so if the structure has changed a lot, you may calculate a different stress when starting from the relaxed structure. You will be able to see from the final stress or pressure whether you should rerun your calculation.</p> <p>Additionally, the cell output will likely be in Quantum Espresso's representation where the cell vectors are given explicitly in Bohr along with a scaling factor <code>alat</code> which is fixed. (In our case here <code>alat</code> will be <code>A</code> converted from Angstrom to Bohr). If you want to rerun your calculation you could either input the cell using these directly, or calculate appropriate values for the input. You may need to do the latter if you want to find the new lattice length anyway.</p>"},{"location":"labs/lab05/readme/#task_4","title":"Task","text":"<ul> <li>So for the silicon case, you'll see the components of the lattice vectors   have changed from 0.5 to 0.497277 or something close to that. What is our   predicted silicon lattice constant?</li> </ul>"},{"location":"labs/lab05/readme/#summary","title":"Summary","text":"<p>In this lab we have seen</p> <ul> <li>How to output forces and stresses in our calculation, and how to check   these quantities have converged.</li> <li>How to use these forces in a calculation to optimize the atomic positions,   where they are moved until the forces on the atoms are less then some   threshold value.</li> <li>How the stresses can be used to optimize the structure, where the lattice   constant is changed until the stress on the system is less than some   threshold value.</li> </ul>"},{"location":"labs/lab05/readme/#extra-optimizing-graphene","title":"Extra: Optimizing Graphene","text":"<p>The folder <code>02_structure/04_graphene</code> contains an input file for graphene. The thing to note in this case is the additional use of <code>cell_dofree = '2Dxy'</code> in the <code>CELL</code> section. We have used this to say that we only want to optimize the cell in the xy plane. The spacing between periodic images in the z-direction should be large enough such that the interaction is small, but we otherwise don't care about the stresses in this direction.</p>"},{"location":"labs/lab05/readme/#task_5","title":"Task","text":"<ul> <li>Starting from the provided graphene input file, find the length of the C-C   bond in graphene to 3 significant figures.<ul> <li>Be sure to test your result is converged with respect to plane wave   energy cut-off and k-point sampling, along with the internal tolerances   being sufficiently small.</li> </ul> </li> </ul>"},{"location":"labs/lab06/readme/","title":"Vibrational Frequencies and Normal Modes","text":"<p>As we saw in the previous lab, we get easy access to the first derivatives of the total energy with respect to various parameters in a basic self-consistent calculation of the density of a system via the Hellmann-Feynman theorem. However, if we want to access second derivatives, so that we can calculate, for example, vibrational frequencies, we need to do a little more. This is linked  to the 2n+1 theorem, which states that the 2n-th or 2n+1-th order  derivative of energies would require the n-the order derivative of electronic wave functions.</p>"},{"location":"labs/lab06/readme/#vibrational-modes-of-methane","title":"Vibrational Modes of Methane","text":"<p>We'll start by calculating the vibrational modes of a molecule. This calculation is set up in 2 parts:</p> <ol> <li>A self consistent calculation of the density and wavefunction. You might    notice this is often the first step in many of the calculations we do.</li> <li>A Density Functional Perturbation Theory (DFPT) calculation of the dynamical matrix and normal modes. As we have a molecule, we only need look at the gamma point here.</li> </ol> <p>This calculation is set up in the <code>01_CH4</code> directory.</p> <ul> <li> <p>First take a look at the input file for the scf   calculation. This doesn't have any inputs you haven't   seen before. There are three things you should take note of though:</p> </li> <li> <p>We've specified the gamma point only by asking for a 1x1x1 unshifted grid,    whereas previously we've usually explicitly asked for the gamma point. This    latter option uses optimizations that can make the calculation a bit faster    if we only use the gamma point, however it does not generate output that is    compatible with the subsequent DFPT calculation of the frequencies, so we    instead specify the gamma point in the manner done in the file.</p> </li> <li> <p>We've re-oriented the molecule relative to what you've seen previously, and    the atomic positions have also been optimized. By specifying the atoms in    this manner, where the components of the hydrogens along each direction    have the same magnitude but different signs, the code is much better able    to detect the symmetry of the molecule. This is very important for    calculations of the vibrations. If the code understands that all the    hydrogen atoms are equivalent by symmetry, it only needs to calculate the    derivatives of the energy with respect to one of the hydrogen positions, and    then it can populate the full dynamical matrix based on the symmetry of the    system.</p> </li> <li> <p>We've increased the default value of <code>ecutrho</code> which is usually four times    the value of <code>ecutwfc</code>. This can help alleviate some issues with acoustic    mode frequencies at gamma mentioned below.</p> </li> </ul>"},{"location":"labs/lab06/readme/#task","title":"Task","text":"<ul> <li>Use this input file to run a calculation with <code>pw.x</code>, and save the output   to a file. Check it worked as expected.</li> </ul> <p>Now take a look at the input file for the DFPT   calculation. This is as follows:</p> <p><pre><code>phonons of CH4 (gamma only)\n &amp;inputph\n  tr2_ph = 1.0d-15\n  asr = .true.\n /\n0.0 0.0 0.0\n</code></pre> - This input file is for the <code>ph.x</code> code which uses the output of a SCF   calculation with <code>pw.x</code> to do a DFPT calculation of the dynamical matrix.   Many more input options are available than we've used here. These are   described in the <code>INPUT_PH.txt</code> file of the quantum espresso documentation.   Alternatively, you can look up   Phonon</p> <pre><code>- Here the first line is a comment. This can be whatever description you\n  like of your input file\n- This is followed by a single section: `INPUTPH`. We've specified two\n  variables here.\n    - `tr2_ph` which defines the threshold for self-consistency, with a\n      default of 1.0d-12.\n    - `asr` which turns on the use of the acoustic sum rule which sets the\n      three translational modes at gamma to zero (or at least near zero).\n      If you take a crystal (or any material) and translate the whole\n      system by some amount in real space, the total energy of the system\n      remains unchanged. If you have a material in three dimensions, you\n      should have three directions where similar translations are possible.\n      Therefore, the phonon polarization vectors and frequencies should\n      reflect such translational invariance. A material in three dimensions\n      should have three phonon modes with zero energy at gamma (as you can\n      translate the material along the x, y, and z directions and it does not cost\n  any energy). These phonon modes are referred to as acoustic phonon\n      modes. In practice, however, the phonon frequencies are never zero-energy as we\n  use a Fast-Fourier-Transform (FFT) grid in our PW calculations. Other\n  factors, such as the tr2_ph parameter can contribute to acoustic\n  phonon frequencies being non-zero. A simple solution to obtain\n  acoustic phonon modes with zero energy is to impose the acoustic sum\n  rule. The sum rule can be imposed on the gamma point dynamical matrix\n  or on the Force-constant matrix (Force constants are obtained using a\n  Fourier Transform of the Dynamical matrix).  For uniform\n  displacements of all the atoms along x/y/z the net forces acting on\n      the atoms are set to zero.\n\n- Following this section, and depending on what input variables have been\n  defined, we can give a list of wavevectors at which we want to calculate\n  the vibrational frequencies. As with the electronic problem, we are\n  modelling a molecule, so only the gamma point makes sense.\n</code></pre>"},{"location":"labs/lab06/readme/#task_1","title":"Task","text":"<ul> <li>Use <code>ph.x</code> to run the calculation using the input file <code>02_CH4_ph.in</code> and save   the output to a file.</li> <li> <p>You'll see along with the output file, several files and folders have been   generated:</p> <ul> <li> <p><code>matdyn</code> (the name of this file can be changed in the input file) - this   stores the dynamical matrix, which can then be passed to several other   codes for further analysis. Take a look at it now.</p> <ul> <li>The top of the file has the atoms, their masses (in internal units)   and positions.</li> <li>This is followed by the dynamical matrix (3x3 complex numbers for   each possible pair of atoms - all the imaginary parts are zero at   gamma).</li> <li>Finally the frequencies of each calculated vibrational mode, both in   THz and cm-1 are given along with the corresponding wavevector. A   molecule with 5 atoms will have 15 possible vibrational modes. This   is how you count vibrational modes/phonons in your system. The    same is valid for crystals at any momentum. If you have N atoms    within the unit-cell of a crystal, you expect d*N phonon modes   for every momentum. In all our simulations, d is 3. In a conventional   material, 3 of these vibrational modes are acoustic i.e.    the energy cost associated with the gamma point is zero. On the other   hand, the rest of the modes (3N-3 of them) cost energy at the gamma point.   These modes are referred to as optical modes. These modes denote   relative displacements of the atoms within the unit cell. Both   acoustic and optical phonon modes can be probed in experiments.   For example, Raman spectroscopy probes the optical modes and   is routinely used in studying materials.  </li> </ul> </li> <li> <p><code>_ph0</code> -  contains intermediate and restart data for the <code>ph.x</code>   calculation.</p> </li> </ul> </li> <li> <p>Now let's look through the output of the <code>ph.x</code> calculation.</p> <ul> <li> <p>Near the top you'll see an analysis of the number of calculations that    need to be done given the symmetry of the system. You'll note that first   3 of the 15 total representations (see below) are computed using the acoustic sum   rule, the next 3 modes are explicitly computed.  This is why it's so   important to have the code detect the symmetry of your system correctly.   Potentially the calculation could have been 5 times slower. Beyond the   undeniable computational speed up, these representations are quite useful in   analyzing the phonon modes, such as during phase transitions in materials, and   Raman activity. They are derived from the so-called theory of irreducible   representation of symmetry groups. Each phonon polarization vector/eigenvector   denotes a pattern on the crystal lattice. Any arbitrary mode will not obey the   full symmetry of the crystal (A symmetry of a crystal is an operation that   leaves the crystal unchanged). The purpose is to group different vibrational   modes associated with their irreducible representations. One often performs all   the symmetry operations of the crystal on the phonon polarization vectors and   categorizes the modes based on the changes caused by the symmetry operations.   Discussion beyond this is out of the scope of this course.  </p> </li> <li> <p>This is followed by a self consistent calculation for each of the   representations that need to be calculated.</p> </li> <li>Then we have the frequencies obtained by diagonalizing the dynamical   matrix.</li> <li>Finally we have a symmetry analysis of the resulting modes, giving   the mode symmetry and whether they should be detectable by Raman or   infrared spectroscropy or both.</li> <li>You'll likely have noticed we have 3 quite negative frequencies. These are   the rotational modes of the molecule. It's difficult to get these to come   out to be zero in the DPFT calculation. In principle this could be enforced   by a suitable constraint in the code, but this is not available in <code>ph.x</code>.   It's possible in some other codes however.</li> <li>The subsequent three modes near zero are the three translational modes, and   these have been enforced to be close to zero by the <code>asr</code> setting in the   input file.</li> </ul> </li> </ul> <p>Note as the frequency is calculated using the square root of the curvature of the energy, a negative frequency is in fact a convention used to indicate that the frequency is imaginary, and the energy curvature is negative. This can indicate some instability in the system, so it is good to ensure you are starting from an optimized structure as you learned how to do last week.</p>"},{"location":"labs/lab06/readme/#task_2","title":"Task","text":"<ul> <li>Try running the calculation with a higher energy cut-off to see how well   converged the vibrational frequencies are. Are the vibrational frequencies   more or less sensitive to cut-off energy than the total energy?</li> </ul>"},{"location":"labs/lab06/readme/#vibrational-modes-of-cfc","title":"Vibrational Modes of CFC","text":"<p>Trichlorofluoromethane, also known as CFC-11 or Freon-11, was formerly used as a refrigerant. It has accumulated in the atmosphere and is a minor contributor to the greenhouse effect. This is because, like methane it absorbs radiation in the thermal IR range where the Earth emits.</p>"},{"location":"labs/lab06/readme/#task_3","title":"Task","text":"<ul> <li>Run the input files in the folder <code>02_CFC</code> using pw.x and ph.x, following the same   process as for methane. Since we need new pseudopotentials (for Cl and F), you will   need to copy them from <code>/opt/Courses/MSE404/pseudo</code> to your own <code>pseudo</code> folder.</li> <li>CFC-11 has a similar (quasi-tetrahedral) structure to methane, however the ph.x   calculation takes a lot longer. Why is this? Hint: think about symmetry.</li> <li>How do the vibrational frequencies compare to methane? Are they consistent with   the fact that CFC-11 is a greenhouse gas?</li> <li>The cut-off energy is set to be relatively small to speed up the calculation, so    that the final results are not well converged. (You may also notice warnings in   the output file about negative density (rho)). It would take too much time to    systematically converge the vibrational frequencies with respect to cut-off, but   you could try increasing the cut-off slightly. How does the change in vibrational   frequencies compare to methane?</li> </ul>"},{"location":"labs/lab06/readme/#phonon-bandstructure-of-carbon-diamond","title":"Phonon Bandstructure of Carbon Diamond","text":"<p>Now that you've seen how to calculate the frequencies at a single wavevector, the next step is to calculate the phonon band dispersion of a crystal. You will learn how to generalize the theory of phonons in molecules to crystals in one of the homework.  The directory <code>03_CarbonDiamond</code> contains a set of input files for carbon diamond.</p> <p>This calculation has five steps:</p> <ol> <li>Perform self-consistent calculation of the density and wavefunction.</li> <li>Calculate the dynamical matrix on a set of wavevectors. We'll call these    q-points from here on, and use k-points to refer to electronic    wavevectors.</li> <li>Fourier transform our grid of dynamical matrices to obtain a set of    real space force constants.</li> <li>Perform an inverse Fourier transform of the real space force constants to    obtain the dynamical matrix at an arbitrary q-point. This allows us    calculate mode frequencies for a fairly dense set of points along lines    between high-symmetry points in the same manner as for the electronic    band structure.</li> <li> <p>Generate the plot.</p> </li> <li> <p>First examine the scf input file in   <code>01_CD_scf.in</code>. This is similar to those   we've seen before. This time we've specified <code>prefix</code>. This can be useful if   you've got different calculations in the same directory. Again, we've   increased <code>ecutrho</code> from its default. The rest is as before.</p> </li> </ol>"},{"location":"labs/lab06/readme/#task_4","title":"Task","text":"<ul> <li> <p>Run <code>pw.x</code> using this input file and save the output.</p> <ul> <li>The other output files generated will be in <code>CD.save</code> since we set the   prefix.</li> <li>Check the output to make sure it completed all right.</li> </ul> </li> <li> <p>Now examine the <code>ph.x</code> input file in   <code>02_CD_ph.in</code>.</p> </li> <li>This is structured as before, but now:<ul> <li>We have specified the same prefix as in the scf input file</li> <li>We've set <code>ldisp = .true.</code> which says we're going to calculate a    grid of q-points.</li> <li><code>nq1</code>, <code>nq2</code> and <code>nq3</code> define our q-point grid then.</li> </ul> </li> </ul>"},{"location":"labs/lab06/readme/#task_5","title":"Task","text":"<ul> <li>Run <code>ph.x</code> using this input file and save the output. This will take maybe 5   or 6 minutes to complete, so feel free to read ahead while it's running.</li> <li>Once complete you'll see several files have been generated in the   calculation directory.<ul> <li><code>matdyn0</code> has the q-point grid used followed by a list of the q-points   at which the dynamical matrix has been calculated.</li> <li><code>matdyn1</code>, <code>matdyn2</code>, etc is the dynamical matrix at each calculated   q-point as before.</li> </ul> </li> <li> <p>Now take a look through the main output file.</p> <ul> <li>You'll see it's quite similar to the methane case, but now contains   a section for each calculated q-point where it figured how how   many represenations need to be calculated based on the symmetry,   an scf cycle for each, and the frequencies and mode symmetries   obtained by diagonalizing the dynamical matrix at that q-point.</li> <li>It's good to look through this file and ensure you're getting   reasonable numbers for the frequencies before proceeding.</li> </ul> </li> <li> <p>Next we'll be generating the real space force constants from our grid of   dynamical matrices using the <code>q2r.x</code> code.</p> </li> <li><code>q2r.x</code> doesn't have a help file like the other codes. You need to inspect   the source file in <code>PHonon/PH/q2r.f90</code> if you download a copy of the   quantum espresso source code. The inputs are all described in a comment   at the top of this file. On the mt-student server you can see this file at   <code>/opt/build/quantum-espresso/q-e-qe-6.3/PHonon/PH/q2r.f90</code>.</li> <li>Take a look at the <code>q2r.x</code> input file   `03_CD_q2r.in. The contents are as follows: <pre><code> &amp;input\n   fildyn = 'matdyn'\n   zasr = 'simple'\n   flfrc = 'CD444.fc'\n /\n</code></pre></li> <li>Here we've specified:<ul> <li><code>fildyn</code>, which is the name of the dynamical matrix files from <code>ph.x</code>,   where we left it at the default value of <code>matdyn</code>.</li> <li><code>zasr</code>, which is the approach used to enforce the acoustic sum rule and    make the acoustic modes go to zero at the gamma point.</li> <li><code>filefrc</code> is the name of the file in which to output the force constants    in real space.</li> </ul> </li> </ul>"},{"location":"labs/lab06/readme/#task_6","title":"Task","text":"<ul> <li>Run <code>q2r.x</code> with this input file now and save the output. This will run   almost instantly.</li> <li> <p>The output isn't particularly interesting. The <code>CD444.fc</code> file has the   force constants for each pair of atoms in each direction for each of the   4x4x4 unit cells in real space.</p> </li> <li> <p>Finally we want to use this to generate our normal mode dispersion. We'll be   doing this with the <code>matdyn.x</code> code. As with <code>q2r.x</code> this doesn't have a doc   file describing its input variables. But you can check the comments at the   top of its source file to get their details. On the mt-student server this   is at <code>/opt/build/quantum-espresso/q-e-qe-6.3/PHonon/PH/matdyn.f90</code>.</p> </li> <li>Take a look at our input file   <code>04_CD_matdyn-bands.in</code>. The   content is as follows: <pre><code> &amp;input\n    asr = 'simple'\n    flfrc = 'CD444.fc'\n    flfrq = 'CD-bands.freq'\n    dos=.false.\n    q_in_band_form=.true.\n /\n8\n 0.000 0.000 0.000 30\n 0.375 0.375 0.750 10\n 0.500 0.500 1.000 30\n 1.000 1.000 1.000 30\n 0.500 0.500 0.500 30\n 0.000 0.500 0.500 30\n 0.250 0.500 0.750 30\n 0.500 0.500 0.500 0\n</code></pre></li> <li>Here we're setting:<ul> <li><code>asr</code> to again tell it to try to force the acoustic modes at gamma to go   to zero.</li> <li><code>flfrc</code> to  give it the name of the file with the real space force   constants from the <code>q2r.x</code> calculation.</li> <li><code>flfrq</code> to give it the name of the output file to store its calculated   frequencies.</li> <li><code>dos=.false.</code> to tell it we're not calculating a density of states</li> <li><code>q_in_band_form=.true.</code> to tell it we want to calculate bands between high   symmetry points.</li> <li>We finally give it a number and list of high symmetry points with the   number of points to calculate along each line, in the same way as we did   for the electronic band structure.</li> </ul> </li> </ul>"},{"location":"labs/lab06/readme/#task_7","title":"Task","text":"<ul> <li>Run <code>matdyn.x</code> using this input file now and save the output. Again this   is very fast.</li> <li>There's very little actual output from the code itself, but it will generate   the files <code>CD-bands.freq</code> and <code>CD-bands.freq.gp</code>. Both of which contain   the frequencies along the lines we requested.</li> <li>Finally we want to generate a plot of these frequencies. We could do that   directly with the previous output: <code>CD-bands.freq.gp</code> is a multicolumn   space separated list of the frequencies in cm-1.<ul> <li>It can be easier to use the <code>plotband.x</code> tool to help generate a plot.</li> <li>Call this with <code>plotband.x CD-bands.freq</code>. This will then ask you for   an Emin and Emax value - you should pick values equal to or below and   above the numbers it suggests. Then it will ask you for an output file   name. Pick \"CD-bands-gpl.dat\" here. You can then cancel further running   of this code with <code>ctrl+c</code>. Note it has output the location of the   high-symmetry points along its x-axis.</li> </ul> </li> <li>Once you've done this, a gnuplot script <code>plotbands.gplt</code> has been provided   that you can use to generate the band structure plot. This is very similar   to the one used for the electronic band structure, but the location of   the high-symmetry points along the x-axis has changed as has the name of   the data file we're plotting. Run this with <code>gnuplot plotbands.gplt</code>.</li> </ul>"},{"location":"labs/lab06/readme/#summary","title":"Summary","text":"<p>In this lab we have seen</p> <ul> <li>For a molecule:<ul> <li>How to use the <code>pw.x</code> code to calculate a converged density and   wavefunction and then use these with the <code>ph.x</code> code to calculate the   vibrational modes using DFPT.</li> </ul> </li> <li>For a crystal:<ul> <li>How to use the <code>pw.x</code> code to calculate a converged density and   wavefunction.</li> <li>How to use these with the <code>ph.x</code> code to calculate the phonon modes on   a grid of wavevectors.</li> <li>How to transform these to obtain real-space force constants using the   <code>q2r.x</code> code.</li> <li>How to use the real-space force constants to obtain a phonon mode   bandstructure along lines between high-symmetry points in the   Brillouin zone.</li> <li>How to plot the bandstructure with gnuplot in a similar way to how we   plot the electronic bandstructure in a previous lab.</li> </ul> </li> </ul>"},{"location":"labs/lab06/readme/#extra-task","title":"Extra: Task","text":"<ul> <li>Calculate the phonon band structure of silicon.</li> </ul>"},{"location":"labs/lab07/readme/","title":"Finite Temperature Properties","text":"<p>Everything we've done so far has in fact been for systems at effectively zero temperature. And even at zero temperature, we haven't taken into account the zero-point motion of the atoms and have treated them as purely classical objects residing at fixed positions.</p> <p>In actuality, there will be an effect from the zero-point motion of the atoms, and as temperature increases the atoms will vibrate with larger amplitude and this can lead to changes in many properties of a material with temperature. You will learn how the thermodynamic properties of a material can be computed from first principles.</p> <p>Our approach will be to use the type of density functional theory (DFT) and density functional perturbation theory (DFPT) calculations you've already seen , and spend more time analysing the output to produce materials properties.</p> <p>This will involve some reasonably serious numerical calculations, of the kind that would be quite difficult to do without using some form of mathematical software. We will use python to compute the thermodynamic properties.</p> <p>We'll be mainly relying on the following libraries:</p> <ul> <li>numpy<ul> <li>This allows us to easily work with arrays of data.</li> </ul> </li> <li>scipy<ul> <li>This gives us many numerical analysis tools.</li> </ul> </li> <li>matplotlib<ul> <li>This allows us to easily generate plots.</li> </ul> </li> </ul> <p>We expect many of you may not be familiar with python, but if you've used Matlab or Mathematica, you should find the process here somewhat similar, but with slightly different syntaxes. Python is a very powerful language that you are most likely to use in future. We will also introduce you to functions and classes. Functions do specific tasks that you wish to perform. For example,  you provide some input, a function does some calculations and returns you an output. Therefore, with a function, you primarily interact (through input \u00a0and output). On the other hand, a class allows you to not only create your own data type but also interact with it. You will find out that class is significantly more re-usable.</p> <p>Let's introduce you to a very simple class. It has two aspects: implementation, and interaction/usage. Let's look at implementation of the position of an atom position: <pre><code># Indentation has to be consistent\n# We are using two spaces as indentation.\n\n# Creating a position class\nclass Position(object):\n  # Special method __init__ to initialize your data\n  # attributes\n  # Note as opposed to normal function, __init__ contains\n  # self;\n  # self: parameter to refer to an instance of a class\n  # x,y: what you provide while creating this class/calling it\n  def __init__(self, x, y):\n    # self.x or self.y: Look for x/y that belong to this class\n    self.x = x\n    self.y = y\n\n  # Methods that you can use to compute things\n  # Following method computes distance of (x,y) from origin\n  def get_dist_from_origin(self):\n    # Note how the x/y values are called (with self.)\n    dist = (self.x**2.0 + self.y**2.0)**0.5\n    return dist\n\n  # You can add as-many methods as you want\n</code></pre> This is the content of <code>position.py</code>. Now, let's see how you can use it. This class can be called to compute the distance of a point from origin. To do this, run the code <code>run.py</code> using : <code>python run.py</code> . Now, take a look inside <code>run.py</code> and try to understand how the calls are made. </p> <pre><code># Import the class Position\nfrom position import Position\n\npos = Position(2,3)\n# Access data from class\nprint(\"x=%.6f\"%(pos.x))\nprint(\"y=%.6f\"%(pos.y))\n# Compute distance by calling the function from class\ndistance = pos.get_dist_from_origin()\nprint(\"distance from origin(0,0)=\",distance)\n</code></pre> <p>Thermodynamic properties of the material involve understanding the phonon occupation number (or, Bose-Einstein distribution), total energy within the harmonic approximation, specific heat at constant volume, Helmholtz free energy, Entropy, etc. In this lab, you will try to learn to code some of these properties by building on some existing code for Diamond.</p>"},{"location":"labs/lab07/readme/#phonon-calculations-on-a-fine-grid","title":"Phonon calculations on a fine-grid","text":"<p>As you might have noticed, we've already done most of the work needed to also calculate phonons on a fine-grid in our previous lab (Lab06/Diamond). This can be done following the <code>q2r.x</code> calculation by choosing some different input options for <code>matdyn.x</code>.  Take a look at the input file <code>05_CD_matdyn-fine.in</code>. The contents are as follows:</p> <pre><code> &amp;input\n    asr='simple'\n    flfrc='CD444.fc'\n    flfrq='CD-fine.freq'\n    nk1=20,nk2=20,nk3=20\n    nosym=.true.\n    dos=.true.\n /\n</code></pre> <p>This is quite similar to the band plot, but now we're setting <code>nosym</code> to true, choosing a dense q-point grid on which to recalculate our frequencies. </p> <p>Run <code>matdyn.x</code> now with this input file. Please do not forget to copy all the things you did in your previous lab on the same material (Copy the files from (Lab06/Diamond) directory into Lab07/CarbonDiamond. It'll take a bit longer than the band calculation as it is explicitly computing without invoking the symmetry. The file it generates: <code>CD-fine.freq</code>. We will utilize this file to compute several thermodynamic properties using python.</p>"},{"location":"labs/lab07/readme/#thermodynamic-properties","title":"Thermodynamic properties","text":"<p>Some key quantities are (For reference, see Wikipedia and  and the reference therein):</p>"},{"location":"labs/lab07/readme/#bose-einstein-distribution","title":"Bose-Einstein distribution","text":"<p>\\(n_{BE}(T) = \\frac{1}{\\exp(\\hbar\\omega(\\mathbf{q}\\nu)/k_\\mathrm{B} T)-1}\\)</p>"},{"location":"labs/lab07/readme/#total-energy-due-to-phonons","title":"Total Energy due to phonons","text":"<p>Total energy due to phonons within harmonic approximation can be  written as,</p> \\[E(T) = \\sum_{\\mathbf{q}\\nu}\\hbar\\omega(\\mathbf{q}\\nu)\\left[\\frac{1}{2} + \\frac{1}{\\exp(\\hbar\\omega(\\mathbf{q}\\nu)/k_\\mathrm{B} T)-1}\\right]\\]"},{"location":"labs/lab07/readme/#constant-volume-heat-capacity","title":"Constant volume heat capacity","text":"<p>Specific heat at constant volume can be obtained from the total  energy calculations:</p> \\[C_{V} = \\left(\\frac{\\partial E}{\\partial T} \\right ) = \\sum_{\\mathbf{q}\\nu} k_\\mathrm{B} \\left(\\frac{\\hbar\\omega(\\mathbf{q}\\nu)}{k_\\mathrm{B} T} \\right)^2 \\frac{\\exp(\\hbar\\omega(\\mathbf{q}\\nu)/k_\\mathrm{B} T)}{[\\exp(\\hbar\\omega(\\mathbf{q}\\nu)/k_\\mathrm{B} T)-1]^2}\\]"},{"location":"labs/lab07/readme/#helmholtz-free-energy","title":"Helmholtz free energy","text":"<p>To compute the Helmholtz free energy, we need the partition function, \\(Z\\).</p> \\[Z = \\exp(-\\varphi/k_\\mathrm{B} T) \\prod_{\\mathbf{q}\\nu} \\frac{\\exp(-\\hbar\\omega(\\mathbf{q}\\nu)/2k_\\mathrm{B}T)}{1-\\exp(-\\hbar\\omega(\\mathbf{q}\\nu)/k_\\mathrm{B} T)}\\] \\[H(T) = -k_\\mathrm{B} T \\ln Z = \\varphi + \\frac{1}{2} \\sum_{\\mathbf{q}\\nu} \\hbar\\omega(\\mathbf{q}\\nu) + k_\\mathrm{B} T \\sum_{\\mathbf{q}\\nu} \\ln \\bigl[1 -\\exp(-\\hbar\\omega(\\mathbf{q}\\nu)/k_\\mathrm{B} T) \\bigr]\\]"},{"location":"labs/lab07/readme/#entropy","title":"Entropy","text":"<p>Entropy, \\(S\\) can also be computed: \\(\\(S = -\\frac{\\partial H}{\\partial T} = \\frac{1}{2T} \\sum_{\\mathbf{q}\\nu} \\hbar\\omega(\\mathbf{q}\\nu) \\coth(\\hbar\\omega(\\mathbf{q}\\nu)/2k_\\mathrm{B}T)-k_\\mathrm{B} \\sum_{\\mathbf{q}\\nu} \\ln \\left[2\\sinh(\\hbar\\omega(\\mathbf{q}\\nu)/2k_\\mathrm{B}T)\\right]\\)\\)</p> <p>Note that the temperature dependence in all these quantities are determined by the Bose-Einstein distribution.</p> <p>We have implemented these codes using python. For example, you will find a folder <code>Thermodynamics</code> containing a file <code>thermo.py</code> that has all these quantities you need. It reads the phonon bands calculations at a fine-grid and can compute several thermodynamic properties. For the implementation of total energy due to harmonic phonon, look up the function, get_E_T inside the <code>thermo.py</code> file:</p> <p><code>def get_E_T(self):     \"\"\"     Computes total energy at a Temperature     @output       E_T, in units of meV       NOTE: E_T/nkp is returned     \"\"\"     E_T = 0.0     # For every band n     for n in range(self.omega_nq.shape[0]):       # For every band q       for q in range(self.omega_nq.shape[1]):         omega = self.omega_nq[n][q]         E_T = E_T + \\               (omega*\\               (0.5 + self.befactor(omega)))     return E_T/self.omega_nq.shape[1]</code></p> <p>You can compute the total energy at a given temperature by running the <code>compute.py</code>: <code>python compute.py</code></p> <p>Try understanding how the calculations are performed and how are they implemented. Note that, all the calculations internaly converts temperature to meV (i.e. \\(T \\to k_{B}T\\)) and phonon energies to meV (from cm\\(^{-1}\\)).</p>"},{"location":"labs/lab07/readme/#task","title":"Task","text":"<ul> <li>Run the calculations at a temperature 20 K.</li> <li>Compute the temperature dependence of \\(E, C_{V}, H, S\\) for    several temperatures, ranging from 10 K to 1000 K in steps   of 20 K. What happens to specific heat at low-temperature?   You will see a lot more details on your homework.   Hint: Write a for loop to do this.</li> <li>Plot these data using matplotlib.</li> <li>Try increasing the grid-size from \\(20\\times20\\times20\\) to a larger number and   try reducing as well. What happens?</li> </ul> <p>NOTE:  An important contribution in the total energy, entropy, etc. are missing in the above calculations: the contribution without the phonons. For example, the total energy of a material at a given temperature is, $$ E(T)= E_{ph}(T) + E_{DFT}$$, where \\(E_{DFT}\\) is the contribution without phonon (sometimes, referred to as lattice energy). Another important point to note is that they are all dependent on the volume of the material. Similarly, the Helmohltz free energy can be written as \\(H = E_{DFT}+ E_{ph} - TS\\). A thermodynamic state is described by two independent parameters, let's take them as \\(T\\) and \\(V\\). The free-energy, \\(H(T,V)\\). So, in principle, one should compute the free-energy for several volumes at any temperature or vice-versa, to represent the thermodynamic state correctly. This leads us to something called, quasi-harmonic approximation. This approximation is a harmonic-phonon-based model used to describe volume-dependent thermal effects, such as the thermal expansion of a material. This approximation assumes that the harmonic approximation holds for every value of the lattice constant, viewed as an adjustable parameter. </p>"},{"location":"labs/lab07/readme/#thermal-expansion-of-a-solid","title":"Thermal Expansion of a Solid","text":"<p>$$ \\alpha = (\\frac{1}{V} \\frac{\\partial V}{\\partial T})$$ at a constant pressure. Note that the volume, \\(V\\) is obtained by minimizing Gibbs free energy, \\(G=H+PV\\). Assuming a zero-external pressure, we can minimize H at every temperature and obtain the thermal expansion coefficient. You will find this in the Si_TEC. </p>"},{"location":"labs/lab07/readme/#task_1","title":"Task","text":"<p>The calculations has three steps: 1. Run the total energy and phonon calculations for several volumes. 2. Compute the Helmohtz free energy for any temperature for these volumes. 3. Obtain the minimum for for each temperature and compute V vs. T. 4. Write a small python code to compute \\(\\alpha\\) using the scripts provided in TEC folder.</p> <p>The first-step can be established using running several calculations<code>bash EvsV.sh</code>. After this step, go to TEC directory and run <code>compute.py</code>.If you recall, it took around 5 minutes to calculate the phonon band-structure for a single volume last time. Doing this 6 times would take half an hour. For this reason, we've included the dos files that would be generated. You don't need to run the calculation here and can proceed to the analysis TEC</p>"},{"location":"labs/lab07/readme/#summary","title":"Summary","text":"<p>In this lab you have seen:</p> <ul> <li>For a solid we used</li> <li>python code to compute several thermodynamic properties computed using DFT+DFPT calculations.</li> </ul>"},{"location":"labs/lab08/readme/","title":"Metals, Spin Polarization and Magnetic Systems","text":"<p>This week we'll cover two topics: metallic systems and spin. For metals, there are a couple of complications which mean we have to treat them differently from systems with a non-zero band gap.</p>"},{"location":"labs/lab08/readme/#metals","title":"Metals","text":"<p>Metals have a Fermi surface that can be quite complex in k-space. This means that in contrast to an insulator or semiconductor where every k-point has the same number of occupied states, in a metal the number of occupied states can vary from k-point to k-point. This makes them more difficult to converge than other systems. </p> <p>In short, there are generally two things you need to do:</p> <ol> <li> <p>Use a denser k-point grid than you would need for a semiconductor or     insulator. This is to help sampling the rapid change in the Fermi surface at     different k-points.</p> </li> <li> <p>Use some smearing scheme. This is in relation to the smearing used in the     calculation of the  density of     states. The difference is that here     the occupation is also smeared (i.e., can no longer be intergers of 0 and     1.) Visually, the smeared DOS would look like the following:</p> <p>where the occupation function (Fermi-Dirac function) is plotted in red. The Fermi energy is obtaeind by solving the following equaion: $$  \\int_{-\\infty}^{\\varepsilon_F} \\mathrm{DOS}(\\varepsilon) f_T(\\varepsilon) d\\varepsilon = N_e  $$ where \\(N_e\\) is the number of electrons in the system and \\(f\\) represents the Fermi-Dirac distribution function at temperature \\(T\\). As we already know,  the Fermi-Dirac function at 0K is a step function which would spoil the convergence of metals. Here, we simply raise the temperature to a small number (<code>degauss</code>) so that the Fermi-Dirac function is smeared out and the Convergence can be more easily achieved. It is worth noting that other smearing methods such as gaussian smearing can also be used.</p> <p>Adding a smearing helps significantly in achieving a smooth SCF convergence, as otherwise a small change in a state energy from once cycle to the next could lead to a very large change in its occupation and to the total energy in turn (this is called 'ill-conditioning').  We set the smearing scheme and width with the <code>occupations</code> and <code>degauss</code>  variables in the input file.</p> </li> </ol>"},{"location":"labs/lab08/readme/#example-aluminium","title":"Example: Aluminium","text":"<p>Aluminium forms in a standard fcc structure with one atom per cell, which we know how to deal with at this point. The thing about Aluminium that makes it more complicated within DFT is that it is a metal.</p> <p>Here is an example input file for a calculation of Aluminium:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n /\n\n &amp;SYSTEM\n    ibrav =  2\n    A = 2.863\n    nat =  1\n    ntyp = 1\n    ecutwfc = 18.0\n    occupations = 'smearing' #(1)!\n    smearing = 'fermi-dirac' #(2)!\n    degauss = 0.1d0 #(3)!\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n Al  26.982  Al.pz-vbc.UPF\n\nATOMIC_POSITIONS crystal\n Al 0.00 0.00 0.00\n\nK_POINTS automatic\n  8 8 8 1 1 1\n</code></pre> <ol> <li>The <code>occupations</code> variable is set to <code>smearing</code> to tell Quantum Espresso       to use a smearing scheme input        description.</li> <li>The <code>smearing</code> variable is set to <code>fermi-dirac</code> to tell Quantum Espresso       to use a Fermi-Dirac smearing scheme. input       description. </li> <li>The <code>degauss</code> variable is set to 0.1d0 to set the width of the smearing.       see input       description.</li> </ol> <p>Task 1 - Smearing</p> <p>First, run the <code>pw.x</code> calculation with the supplied input file in 01_aluminium/Al.in.</p> <p>Then, look in the <code>pwscf.xml</code> file and find the various <code>ks_energies</code> entries towards the end. These give the various k-points used in the calculation and the energies and occupations of each state for this k-point. Note, for a metal the default number of bands is at least four more than are needed for the number of electrons per cell. The pseudopotential we have used has 3 valence electrons, which could be represented with two potentially doubly occupied bands, so we have four more bands in the calculation for a total of 6.</p> Example <pre><code>      &lt;ks_energies&gt;\n        &lt;k_point weight=\"7.812500000000000E-003\"&gt;-6.250000000000000E-002  6.250000000000000E-002  6.250000000000000E-002&lt;/k_point&gt;\n        &lt;npw&gt;59&lt;/npw&gt;\n        &lt;eigenvalues size=\"6\"&gt;\n  1.315972343567215E-001  1.505697520824042E+000  1.607697079464305E+000\n  1.607697714947740E+000  1.834366371282428E+000\n  1.952726961146777E+000\n        &lt;/eigenvalues&gt;\n        &lt;occupations size=\"6\"&gt;\n  9.999990177787399E-001  1.181697427742303E-006  1.536561074875367E-007\n  1.536541545820267E-007  1.650917762173208E-009\n  1.547598926179030E-010\n        &lt;/occupations&gt;\n      &lt;/ks_energies&gt;\n ... \n</code></pre> <p>Now, try removing the <code>occupations</code> and <code>degauss</code> variables from the input file and see what happens when you try to run the calculation.</p> Example <pre><code>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n     Error in routine electrons (1):\n     charge is wrong: smearing is needed\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</code></pre>"},{"location":"labs/lab08/readme/#spin-polarization","title":"Spin Polarization","text":"<p>Up till now we have been assuming that we always had some set of bands which could each fit two identical electrons. Essentially we have been ignoring the electron spin. If you want to examine, for example, a magnetic system then the spin of the electrons is important. It can also be important in modelling atomic or molecular systems. We'll cover different examples of this in this lab. </p>"},{"location":"labs/lab08/readme/#the-oxygen-molecule","title":"The Oxygen Molecule","text":"<p>If a system is not necessarily magnetic we might imagine that representing  it with some set of fully occupied, doubly degenerate bands will work. However, in some cases including spin polarization can lead to important differences. One example of this is the O2 molecule.</p> <p></p> <p>In this case, we have a system with two interacting oxygen atoms. Each oxygen has 8 electrons in total, with the configuration <code>1s2 2s2 2p4</code> (the 1s orbital will be contained within the pseudopotential for the DFT calculations done here, so you will have 6 electrons from each oxygen atom). </p> <p>For a single oxygen, from Hund's rule the three p orbitals should be filled singly before being filled in pairs, so that one of the p-orbitals will have two electrons, and the other two should have one each. However, if we assume doubly occupied orbitals, we'll have the two p-orbitals with two electrons and one that is empty. This means a calculation where we assume a set of doubly occupied bands will have trouble converging to the ground state of the system. For the molecule the situation is similar, but the s and p orbitals from each atom combine to form bonding and anti-bonding \\(\\sigma\\) and \\(\\pi\\) orbitals.</p> <p>The directory <code>02_O2</code> contains an input file to calculate the total energy of the system at the measured bond length. Here the calculation has been set up exactly as you've seen in the past (i.e., assuming doubly degenerate band occupation without smearing or spin polarization:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n /\n\n &amp;SYSTEM\n   ibrav = 1\n   A = 10\n   nat = 2\n   ntyp = 1\n   nbnd = 8\n   ecutwfc = 60.0\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n O  15.9999  O.pz-rrkjus.UPF\n\nATOMIC_POSITIONS angstrom\n O  0.0   0.0  0.0   0 0 0\n O  1.48  0.0  0.0   1 0 0\n\nK_POINTS gamma\n</code></pre> <p>Task 2.1 - Assming Spin Degenerate Insulator</p> <p>Try running the calculation in this directory. Does it converge?</p> Answer <p>While it's possible that the system may randomly meet the convergence criteria in the self-consistent cycle, this calculation will most likely not converge. If you look at the estimate accuracy at the end of each iteration in the output, it will likely vary from step to step, rather than steadily decreasing as in a well-behaved calculation.</p> <p>The situation we have is similar to a metal: we have two bands and the ground state of the system should be when there is one electron in each of them.</p> <p>To get around this, we can use a metallic occupation scheme with a small smearing width. This will allow the system to converge to the correct ground state. The relevant input variables are the ones highlighed below:</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n /\n\n &amp;SYSTEM\n   ibrav = 1\n   A = 10\n   nat = 2\n   ntyp = 1\n   nbnd = 8\n   ecutwfc = 60.0\n   occupations = 'smearing' \n   smearing = 'fermi-dirac'\n   degauss = 0.1d0\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n O  15.9999  O.pz-rrkjus.UPF\n\nATOMIC_POSITIONS angstrom\n O  0.0   0.0  0.0   0 0 0\n O  1.48  0.0  0.0   1 0 0\n\nK_POINTS gamma\n</code></pre> <p>Task 2.2 - Assuming Spin Degenerate Metal</p> <p>Create a copy of the <code>02_O2</code> directory called <code>02_O2_metal</code>. Modify the input file in it to use a metallic occupation scheme with a small smearing width and run the calculation (as above). </p> <ul> <li>Does the calculation now converge?</li> </ul> Answer <p>Yes, the calculation should now converge.</p> <ul> <li>Take a look at the file <code>pwscf.xml</code> in the calculation directory, and   try to find the occupations of each band at each k-point. Are these as   expected?</li> </ul> Answer <p>The occupations should be fractional for the highest occupied valence band which is not physical for a molecule. <pre><code>        &lt;occupations size=\"8\"&gt;\n  9.999997613058770E-001  9.999680732750561E-001  9.800308333633008E-001\n  9.433101748955524E-001  9.433101708179502E-001\n  5.459533880551336E-001  5.459533513549418E-001  4.147424691420094E-002\n        &lt;/occupations&gt;\n</code></pre></p> <p>While treating this system as a metal may help converging the calculation, it may not necessarily reach the ground state since the spin-degress of freedom is constrained. Instead, we can do a spin polarized calculation by adding <code>nspin</code> and <code>tot_magnetization</code> variables to the input file (highlighted below):</p> <pre><code> &amp;CONTROL\n    pseudo_dir = '.'\n /\n\n &amp;SYSTEM\n   ibrav = 1\n   A = 10\n   nat = 2\n   ntyp = 1\n   nbnd = 8\n   ecutwfc = 60.0\n   nspin = 2 #(1)!\n   tot_magnetization = 2.0 #(2)!\n /\n\n &amp;ELECTRONS\n /\n\nATOMIC_SPECIES\n O  15.9999  O.pz-rrkjus.UPF\n\nATOMIC_POSITIONS angstrom\n O  0.0   0.0  0.0   0 0 0\n O  1.48  0.0  0.0   1 0 0\n\nK_POINTS gamma\n</code></pre> <ol> <li><code>nspin</code>: this is 1 by default so no spin polarization is taken into        account. To perform a spin polarized calculation it should be set to 2.</li> <li><code>tot_magnetization</code>: this is difference between the number of spin-up and       spin-down electrons in the cell. If we want a single spin up electron       we can set this to <code>1.0</code>.</li> </ol> <p>Task 2.3 - Assuming Spin Polarized Metal</p> <p>Create another copy of <code>02_O2</code> called <code>02_O2_spin</code>. Then, try to:</p> <ol> <li> <p>Only turn on spin polarization. Does the calculation run?</p> Answer <p>The calculation will not run. <pre><code>%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n    Error in routine iosys (1):\n    fixed occupations and lsda need tot_magnetization\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n</code></pre></p> </li> <li> <p>Setting the total magnetization to 0, which would be the case if we     don't have any net magnetization in the molecule, as both spins point in    opposite directions. </p> Answer <p>The calculation converges to an energy of -63.25520699 Ry.</p> </li> <li> <p>Setting the total magnetization to 2.0, which corresponds    to both spins pointing in the same direction. Is the energy lower? How do    the orbital energies vary?</p> Answer <p>The calculation converges to an energy of -63.29338911 Ry. The energy becomes lower with this configuration and the orbital energies become different between spin channels. <pre><code>      &lt;ks_energies&gt;\n        &lt;k_point weight=\"1.00000000000000\"&gt;0.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000&lt;/k_point&gt;\n        &lt;npw&gt;26462&lt;/npw&gt;\n        &lt;eigenvalues size=\"16\"&gt;\n -1.025922874232402E+000 -7.812538236389854E-001 -4.590520636167327E-001\n -4.198711506107195E-001 -3.871387741292614E-001\n -2.912685945326537E-001 -2.532555221576769E-001 -1.076727247566867E-001\n -1.025922792354764E+000 -7.812537346931661E-001\n -4.590520549643138E-001 -4.198710925526331E-001 -3.871386455493686E-001\n -2.912685126157339E-001 -2.532553593136832E-001\n -1.076726566570645E-001\n        &lt;/eigenvalues&gt;\n        &lt;occupations size=\"16\"&gt;\n  1.000000000000000E+000  1.000000000000000E+000  1.000000000000000E+000\n  1.000000000000000E+000  1.000000000000000E+000\n  1.000000000000000E+000  0.000000000000000E+000  0.000000000000000E+000\n  1.000000000000000E+000  1.000000000000000E+000\n  1.000000000000000E+000  1.000000000000000E+000  1.000000000000000E+000\n  1.000000000000000E+000  0.000000000000000E+000\n  0.000000000000000E+000\n        &lt;/occupations&gt;\n      &lt;/ks_energies&gt;\n</code></pre></p> </li> </ol> <p>Finally, comparing the energy of the spin polarized calculation with the spin degnerate metal calculation, we can see that the spin polarized calculation gives a lower energy.</p> <p>Fun facts</p> <p>O2 in its singlet state can be dangerous (see e.g.  <code>this paper</code>), so treating the spin correctly is important!</p>"},{"location":"labs/lab08/readme/#iron","title":"Iron","text":"<p>Now that you've seen how including spin polarization can allow us a correctly describe the ground state of our system in your calculation, the next step is to use it to describe a magnetic system.</p> <p>In a magnetic system there is a net spin polarization in the unit cell. This means that we'll probably have an odd number of electrons, and the energy of the system when we include a net spin polarization is lower than the energy when we don't.</p> <p>One of the most common magnetic systems is iron, so we'll examine this. The directory <code>03_Fe</code> contains an input file for iron. Note this is a BCC structure (as set by <code>ibrav = 3</code> in the input file), whereas most of the crystals structures you have examined previously were FCC. The calculation has been set up in the usual way for a metallic system.</p> <p>Task 3.1 - fixed magnetization</p> <ol> <li> <p>Run this calculation and check everything worked as expected. What is the    final energy?</p> Answer <p>The final energy should be -55.52528610 Ry.</p> </li> <li> <p>Now make a copy of the calculation directory and in this, modify the    calculation to turn on spin polarization. Try running the calculation    with <code>tot_magnetization = 0.0</code> first, and compare your total energy to that    obtained using doubly degenerate bands. </p> <p>Note</p> <p>while in the case of the O2 above, we were able to get our calculations to at least converge by using a metallic occupation instead of using spin polarization, in the case of iron, it will still be a metal when you use spin polarization, so you should not remove the input variables associated with this. </p> Answer <p>The total energy becomes -55.52528589 Ry. Almost identical to the one obtained with the doubly degenerate bands. This is because these two calculations are essentially identical.</p> </li> <li> <p>Now try setting the total magnetization to 1.0 and see how total energy    changes: Which is the more energetically favourable configuration?</p> Answer <p>The total energy becomes -55.53839616 Ry. Lower than the spin degenerate case.</p> </li> <li> <p>Try setting the total magnetization to 2.0. How does the final energy    compare to the previous value?</p> Answer <p>The total energy becomes -55.56226730 Ry. Lower than all previous cases.</p> </li> </ol> <p>From this we could test many guesses for the total magnetization, and find the value which gives the lowest overall total energy. However, we can instead pass an option that tells quantum espresso to automatically find the best value. This is done by setting the <code>starting_magnetization</code> input variable.</p> <p>Task 3.2 - Relaxed magnetization</p> <ol> <li> <p>Make another copy of the <code>03_Fe</code> directory, and this time set <code>nspin = 2</code>,    and <code>starting_magnetization = 1.0</code> (do not include the    <code>tot_magnetization</code> variable as this fixes a value). Run the calculation    and see what the final total magnetization per cell is. See if you can    find a measured value for iron to compare to.</p> Answer <p>The total magnetization becomes larger than 2.0. <pre><code>total magnetization       =     2.21 Bohr mag/cell\n</code></pre> This is becuase we are allowing the spin to fully relax in the system.</p> </li> <li> <p>See if you can use what we covered in previous labs to calculate and make a    plot of the electronic band structure of BCC Fe.</p> <ul> <li>Plot the spin-up and spin-down bands in different colours.</li> <li>Indicate the Fermi energy on your plot in some sensible way.</li> <li>As the Brillouin zone is different to the ones you have calculated so   far you'll need to select a few sensible high-symmetry points yourself   to plot with .</li> </ul> Answer <p>You can find the relevant input file in the directory  <code>03_Fe/extra_bandstructure</code>. Give the <code>run_all.sh</code> file a read and try to run the calculation. The band structure should look like The following:  </p> </li> </ol>"},{"location":"labs/lab08/readme/#summary","title":"Summary","text":"<p>In this lab you have seen:</p> <ul> <li>How to treat a metallic system.</li> <li>How to do a DFT calculation including spin polarization.</li> <li>How some systems need to be done with spin polarization to converge to the   correct ground state.</li> <li>How to use spin polarized calculations to find the correct magnetization of a   magnetic system by letting the code find the total magnetization that produces   the lowest overall total energy.</li> </ul>"},{"location":"labs/lab09/readme/","title":"Charged system and excited states","text":"<p>Reminder Don't forget to copy the <code>lab09</code> folder from <code>/opt/Courses/MSE404/lab09</code> to your home directory.</p> <p>In this lab we're going to see how properties of charged systems can be obtained with DFT, and how to improve the description of excited states (remember DFT is formally a theory that allows us to compute ground state and excited states properties by knowing the ground state density only!).</p>"},{"location":"labs/lab09/readme/#ionization-potential-and-electron-affinity","title":"Ionization potential and electron affinity","text":"<p>As a first step, we will look at how to compute ionization energies and electron affinities in molecules, specifically carbon monoxide (CO). To do this, we will employ the \\(\\Delta\\)SCF method, i.e. we will perform SCF calculations for the neutral molecule (with \\(N\\) electrons) and the charged molecule (\\(N\\pm 1\\) electrons) at the geometry of the neutral molecule and compute the difference in the total energies (\\(E_{N} \\pm E_{N+1}\\)). In doing so, we are neglecting the effect of geometry relaxation in the charged system, and therfore the difference in nuclear-nuclear repulsion energies, that would be different in two different geometries. However, photoemission is a fast process and therefore the neglect of relaxations in the charged state is often justified when comparing to  experiments.</p> <p>Due to the long-range nature of the Coulomb interaction, electrostatic sums on an infinite lattice, or equivalently,  in a system subject to periodic boundary conditions (PBC), are not always absolutely convergent and in fact  the sum is divergent if the system is charged, which makes the above-mentioned energy differences ill-defined.  When using PBC, one can simulate an isolated molecule using a supercell with enough vacuum space. However, the energy calculated for a finite  supercell differs from that of an infinite supercell, because of the spurious interactions  of the charged system and its periodic images (as we have seen already this is also true for  neutral system with no permanent dipole, but in this case the electrostatic sum is absolutely  convergent and one can get away with a relatively small supercell size).</p> <p>In DFT code with PBC, charged systems are usually addressed by introducing a compensating  uniform jellium background, such that the total charge of the supercell is zero. This is of course an approximation  and it's only justified in the \\(L\\rightarrow\\infty\\) limit, where \\(L\\) is the linear dimension  of the supercell. Hence, one way to study charged systems within DFT is to compute the total  energy for increasing values of the supercell size and extrapolating from these the  value at \\(L\\rightarrow\\infty\\). </p> <p>More refined methods have been developed to treat charged systems within PBC and small supercells, such as the Makov-Payne method and Martyna-Tuckerman method,  which we will also use in this lab. The Makov-Payne method applies a cell size-dependent correction to the total energy based on an asymptotic analysis of the total energy of charged system with respect to the supercell size. This allows to get a faster convergence with respect to the supercell size. The Martyna-Tuckerman method, on the other hand, introduces a cut-off in real space beyond which interactions are set to zero. As a rule of thumb, the supercell  should be more than twice as large as the size of the molecule for this to be a good approximation.</p> <p>In Quantum ESPRESSO you can enable the calculation of charged systems by setting <code>tot_charge = +1</code>, if one electron is removed, or <code>tot_charge = -1</code>, if one electron is added, and so on, in the <code>SYSTEM</code> section of the input file. When having an odd number of electrons (e.g. an unpaired electron) we also need to perform a spin-polarised calculation, since we now have a different number of electrons in the two spin-channels. This can be done by setting <code>nspin=2</code>. Finally, we need to specify the occupation of the Kohn-Sham states. In molecules, with non-dengerate HOMO-LUMO, we want that each KS state is either fully occupied or empty. This can be achieved by setting <code>occupations=fixed</code>.</p> <p>The molecular orbitals diagram for the CO molecule can be found at this website </p>"},{"location":"labs/lab09/readme/#task","title":"Task","text":"<p>Compute the ionization energy of carbon monoxide. You can find input files and annotated scripts in the <code>01_carbon_monoxide</code> folder.</p> <ul> <li>Inspect the <code>CO_neutral.in</code> (neutral) and <code>CO_charged_p1.in</code> (positively charged, one electron removed) template files</li> <li>Use the <code>run_cell.sh</code> bash script to run SCF calculations for increasingly large cell sizes.    The script generates a text file <code>&lt;template_name&gt;_etot_v_box.dat</code> with two columns: first column is the linear    dimension of the cubic cell in angstroms and second column is total energy in Rydberg.</li> <li>The script can be used both for the neutral and the charged system. You will have to modify the <code>template</code>    variable in the script accordingly. Run the script for both neutral and charged system.</li> <li>Check it is converged for all cell sizes. </li> <li>After running the script for the neutral and charged molecule, create a text file with two columns, with first    column being the linear dimension of the cell in angstroms and second column being the difference    between total energies of charged and neutral molecule in Rydberg.</li> <li>Use the <code>deltaE_v_box.gnu</code> gnuplot file to do a linear fit (\\(f(x) = a + bx\\)) of \\(E_{N-1}-E_{N}\\) vs \\(1/L\\). Modify the    script such that it reads the file you have generated in the previous point. In the script you will have to substitute   <code>FILENAME</code> with the name of your file.   Run the script by typing <code>gnuplot deltaE_v_box.gnu</code>.    This should generate a plot with and  you should get the resulting \\(a\\) and \\(b\\) parameters as well as the standard    error from the fitting displayed in the terminal <pre><code>Final set of parameters            Asymptotic Standard Error\n=======================            ==========================\na               = 14.19            +/- 0.01085      (0.07643%)\nb               = -22.8611         +/- 0.1496       (0.6543%)\n\ncorrelation matrix of the fit parameters:\n                a      b      \na               1.000 \nb              -0.972  1.000\n</code></pre></li> <li>Extract the value for \\(L\\rightarrow\\infty\\), i.e. \\(1/L=0\\). The experimental value is \\(14.01\\) eV. How does it compare with   the DFT result?</li> </ul>"},{"location":"labs/lab09/readme/#task_1","title":"Task","text":"<p>Compute the electron affinity of carbon monoxide.  - Re-do the same steps of previous task replacing <code>CO_charged_p1.in</code> with <code>CO_charged_m1.in</code>.  - For the calculation of the electron affinity we have changed the occupations from <code>fixed</code> to <code>smearing</code>.  From the diagram of molecular orbitals of CO, can you explain why? - The experimental value is \\(1.326\\) eV. How does this compare with the DFT result?</p>"},{"location":"labs/lab09/readme/#task_2","title":"Task","text":"<p>Compute the electron affinity and ionization energy using the Makov-Payne method and Martyna-Tuckerman method to treat  the charged system at a relatively small cell size. In <code>02_carbon_monoxide</code> folder copy the input files of the  charged systems and set the supercell size to 16 Angstroms. The cartesian coordinates for the C and O atoms are <pre><code> C  8.000 8.000 7.436\n O  8.000 8.000 8.564\n</code></pre> To use these methods, we need to add <code>assume_isolated='mp'</code> for Makov-Payne and <code>assume_isolated='mt'</code> for Martyna-Tuckerman in the <code>SYSTEM</code> section.</p> <p>Run <code>pw.x</code> with these input files and compare the ionization energy and electron affinity with that of  an infinite supercell from the extrapolation. </p>"},{"location":"labs/lab09/readme/#excited-states-and-band-gap-problem-titanium-dioxide-rutile","title":"Excited states and band-gap problem - Titanium dioxide (Rutile)","text":"<p>It is well known that in insulators and semiconductors the fundamental band gap is underestimated by DFT with local (LDA) and semilocal (GGA) exchange-correlation (XC) functionals. This can be related to local and semilocal XC functionals being unable to remove spurious self-interactions arising from the Hartree term. For instance, if  we consider a simple one-electron system like the hydrogen atom, one can easily see that the Hartree energy \\(E_{H}[n] = \\frac{1}{2} \\int \\frac{n(\\mathbf{r})n(\\mathbf{r}')}{|\\mathbf{r}-\\mathbf{r'}|} d^3r d^3r'\\) implies an unphysical self-interaction of the electron with itself. This contribution should be compensated by the XC term, but an exact cancellation is not possible with local and semilocal functionals. This means that a percentage of this spurious contribution remains and pushes up the energies of the occupied states. At the same time, unoccupied states do not contribute to the total density and therefore no self-interaction term arises from them. As a net result, the gap between occupied and unoccupied states is reduced.</p> <p>To ameliorate this problem several so-called hybrid XC functionals have been proposed. These are non-local XC functionals based on the electron density and Kohn-Sham orbitals as well, i.e. \\(E_{XC}^{hyb} [n(\\mathbf{r}),{\\phi_{KS}(\\mathbf{r})}]\\). The main idea, is to add to the (semi)local XC functionals a percentage of the exact exchange term, which is a functional of the KS orbitals. In fact, from Hartree-Fock  theory it is well known that there is a perfect cancellation between the Hartree and the Exchange terms for the self-interaction.</p> <p>In this part we are going to compute the band structure of titanium dioxide (rutile phase) with a semilocal XC functional (PBE) and  we will see how using the <code>B3LYP</code> hybrid XC functional improves the band gap compared to the experimental value. You are not going to explicitely run a DFT calculation with a hybrid functional as this is quite computationally demanding, particularly with a plane-wave basis set (can you think of why?)</p> <p>The B3LYP energy functional is a very popular hybrid functional and it is obtained by: \\(E_{XC}^{B3LYP} = (1-a)E_{X}^{LSDA} + a E_{X}^{HF} + b \\Delta E_{X}^{B88} + (1-c)E_{C}^{LSDA} + c E_{C}^{LYP}\\), where the subscrpits \\(X\\) and \\(C\\) mean exchange and correlation, respectively. The superscripts, on the other hand, identify the different functional forms, for instance \\(HF\\) means Hartree-Fock, \\(LSDA\\) means local spin-density approximation, \\(B88\\) Becke88 functional and \\(LYP\\) the Lee-Young-Parr functional. The three parameters in B3LYP have the following values \\(a=0.2\\), \\(b=0.72\\) and \\(c=0.81\\). Finally \\(\\Delta E\\) means a gradient correction to the functional. You can see that in B3LYP one introduces a fraction (0.2) of the Hartree-Fock exchange, which is a non-local functional.</p> <p>The rutile phase of TiO2 is a direct wide-gap semiconductor, with an experimental bandgap of \\(3.3\\) eV. The unit cell is tetragonal with  <code>a=4.58</code> Ang and <code>c=2.95</code> Ang and contains six atoms, two Ti atoms and four O atoms. You can visualise the structure using <code>xcrysden</code> as usual.</p>"},{"location":"labs/lab09/readme/#task_3","title":"Task","text":"<ul> <li>Let's first calculate the rutile band structure with a semilocal XC functional (PBE). In <code>03_rutile</code> folder you will find an input file <code>01_rutile_scf.in</code> for a SCF calculation and two pseudopotential files <code>Ti.pbe-sp-van_ak.UPF</code> and <code>O.pbe-van_ak.UPF</code>. Copy these two files into your <code>pseudo</code> folder and run <code>pw.x</code> to obtain the ground state density.</li> <li>Next, let's compute the band structure on a high-symmetry path by running a non-scf calculation. You will have to use the <code>01_rutile_nscf.in</code> input file.</li> <li>Finally, let's plot the bands with <code>bands.x</code> as you have done in Lab 4. You will have to use <code>01_rutile_bands.in</code> and plot the result with <code>gnuplot</code>. At which high-symmetry point is the direct band gap found?</li> <li>Go back to the output of the non-scf calculation and compute the band gap from the lowest unoccupied state and highest occupied states at \\(\\Gamma\\). You should get a band gap of \\(1.9\\) eV, which is \\(~1/3\\) smaller than the experimental value.</li> <li>Now look at the output file <code>02_rutile_scf.in</code>, which has been obtained with the B3LYP XC functional. At the end of the file you can check the  difference between the lowest unoccupied state and the highest occupied state. This calculation is not fully converged but you can see that the band gap is now much closer to the experimental value.</li> </ul>"},{"location":"labs/lab09/readme/#summary","title":"Summary","text":"<ul> <li>In this lab we've looked at how to treat charged molecules with DFT and periodic   boundary conditions. We have also looked at how ionization energies and electron   affinities can be computed with \\(\\Delta\\)SCF.</li> <li>We've also looked at how more refined methods can help with the convergence   of the total energy with respect to the cell size for charged molecules, e.g.   the Makov-Payne method and Martyna-Tuckerman method.</li> <li>In the second part we have looked at hybrid exchange-correlation functionals and   how these can improve the description of excited states and ameliorate the    band-bap problem in insulators and semiconductors.</li> </ul>"}]}